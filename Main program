def game():
    global steps
    global Board
    global Size
    global Type_error
    global Difficulty
    global rec_step
    if Type_error:
        Type_error=False
    else:
        print_board()
    found=False
    x=0
    y=0
    while found != True: #Automated relocate player position
        if Board[x][y] == "P":
            found=True
        else:
            y=y+1
            if y > (Size-1):
                x=x+1
                y=0
                if x > (Size-1):
                    print("System: ERROR")
                    print("System: Player position not found, please restart the game")
                    ans=input("System: Press Enter to exit the game ")
                    sys.exit()
    if Difficulty == 5:
        if steps == rec_step:
            end(False)
    ans=input("System: Please enter the direction you want to move ")
    ans=ans.lower()
    if ans == "w": #Move up
        if y < (Size-1) and Board[x][y+1] != "X":
            Board[x][y]=" "
            y=y+1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move up")
            Type_error=True
    elif ans == "s": #Move down
        if y > 0 and Board[x][y-1] != "X":
            Board[x][y]=" "
            y=y-1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move down")
            Type_error=True
    elif ans == "a": #Move left
        if x > 0 and Board[x-1][y] != "X":
            Board[x][y]=" "
            x=x-1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move left")
            Type_error=True
    elif ans == "d": #Move right
        if x < (Size-1) and Board[x+1][y] != "X":
            Board[x][y]=" "
            x=x+1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move right")
            Type_error=True
    elif len(ans) != 1:
        print("System: Out of Range!")
        print("System: Please enter single character")
        Type_error=True
    else:
        print("System: Invalid input!")
        print("System: Please enter 'W', 'A', 'S', or 'D'")
        Type_error=True
    game()

def end(win):
    global steps
    global rec_step
    if win:
        print("System: Congratulations!")
        print("System: You have exited the maze!")
        print("System: Total steps taken:", steps)
        print("System: Maze recommended steps:", rec_step)
    else:
        print("System: Game Over")
        print("System: You have used all of the steps")
        print("System: Total steps taken:", steps)
        print("System: Maze recommended steps:", rec_step)
    time.sleep(0.5)
    ans=input("System: Press Enter to exit the game or type '/restart' to restart the game ")
    if ans.lower() == "/restart":
        for i in range(5):
            print("")
        main()
    else:
        sys.exit()

def print_board(): #0,0 at bottem left corner
    global Board
    global Size
    print("")
    for y in range(Size):
        h=Size-y-1 #Height of the board
        if h<10:
            temp="0"+str(h)
        else:
            temp=str(h)
        print(temp, *[Board[x][h] for x in range(Size)])
    print("")

def build_maze():
    global Board
    global Size
    mn=str(random.randint(1,999)) #Random generate maze ID
    print("System: Loading Maze 0"+mn+"...")
    i=2 #Maze generation method using
    if i == 1: #Loop-erased random walk method
        #Maze format: node only
        #Board format: node and line(path)
        #Grid format: Location vector in "0519" form, x=5 y=19
        Board=[["X"] * Size for z in range(Size)]
        time.sleep(0.1)
        x=1
        y=1
        Board[x][y]=" "
        Maze=[["F"] * int((Size-1)/2) for n in range(int((Size-1)/2))] #Store the cell that are part of the maze, grid is stored in node form, lines are not included
        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
        y=int((x+1)/2-1)
        Maze[x][y]="T"
        Done=False #Register maze is fully finished
        while not(Done): #Check is all node included in the maze
            Done=True
            Not_Maze=[] #The cell that are not part of the maze, 1D array, in maze format
            for h in range(0,len(Maze)): #x-axis
                for v in range(0,len(Maze)): #y-axis
                    if Maze[h][v] == "F": #Check is it part of maze
                        Done=False
                        Not_Maze.append(grid(h,v)) #Storing the Location vector in Grid format
            if not Done:
                temp=Not_Maze[random.randint(0,len(Not_Maze)-1)] #In Maze format
                x=int(temp[0:2])
                y=int(temp[2:4])
                x=2*x+1 #Converting location vector from Maze format to Board format
                y=2*y+1
                Path=[temp] #Stored walked path, in Board format
                while Maze[int((x+1)/2-1)][int((y+1)/2-1)] != "T":
                    retry=False
                    Direction=random.randint(1,4) #1:Up 2:Down 3:Left 4:Right
                    Steps=random.randint(1,2)*2
                    if Direction == 1: #Move up
                        if y+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                y=y+1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 2: #Move down
                        if y-Steps <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                y=y-1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 3: #Move left
                        if (x-Steps) <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x-1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 4: #Move right
                        if x+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x+1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                for n in range(0, len(Path)-1): #Register paths into maze
                    temp=Path[n] #Load grid into temp, in Board format
                    x=int(temp[0:2])
                    y=int(temp[2:4])
                    Board[x][y]=" "
                    if n%2 == 0 :
                        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
                        y=int((y+1)/2-1)
                        Maze[x][y]="T"
                check_state(Maze,Not_Maze,Done)
                for k in range(Size): #Redraw the edge
                    Board[0][k] = "X"
                    Board[Size-1][k] = "X"
                    Board[k][0] = "X"
                    Board[k][Size-1] = "X"
    elif i == 2: #Recursive division method
        #Grid format: Location vector in "0519" form, x=5 y=19
        Board=[[" "] * Size for z in range(Size)]
        for k in range(Size): #Draw the edge
            Board[0][k] = "X"
            Board[Size-1][k] = "X"
            Board[k][0] = "X"
            Board[k][Size-1] = "X"
        Chunk=[] #Store the chunks, each chunck stored in oreder of Top left corner, Top right corner, Bottom left corner, Bottom right corner in Grid format
        Chunk_num=0 #Number of chunks
        Chunk_num_F=0 #Number of chunks that are fully finished
        for n in range(0,4):
            if n == 0: #Top left corner of the chunk
                x=1
                y=Size-2
            elif n == 1: #Top right corner of the chunk
                x=Size-2
                y=Size-2
            elif n == 2: #Bottom left corner of the chunk
                x=1
                y=1
            elif n == 3: #Bottom right corner of the chunk
                x=Size-2
                y=1
            Chunk.append(grid(x,y)) #Storing the Location vector in Grid format
        Chunk_num=Chunk_num+1
        Done = False #Register maze is fully finished
        while not(Done): #Check is the maze finished
            Chunk_TL=Chunk[0] #Top left corner of the chunk
            Chunk_TR=Chunk[1] #Top right corner of the chunk
            Chunk_BL=Chunk[2] #Bottom left corner of the chunk
            Chunk_BR=Chunk[3] #Bottom right corner of the chunk
            x_TL=int(Chunk_TL[0:2]) #Converting Grid format to location vector (x), path
            y_TL=int(Chunk_TL[2:4]) #Converting Grid format to location vector (y), path
            x_TR=int(Chunk_TR[0:2])
            y_TR=int(Chunk_TR[2:4])
            x_BL=int(Chunk_BL[0:2])
            y_BL=int(Chunk_BL[2:4])
            x_BR=int(Chunk_BR[0:2])
            y_BR=int(Chunk_BR[2:4])
            if (x_TL == x_TR) or (y_TL == y_BL): #Check is the chunk is too small
                Chunk_num_F=Chunk_num_F+1 #Update the number of chunks that are fully finished
                for n in range (0,4):
                    Chunk.pop(0) #Remove the completed chunk
            else:
                x_Cut=random.randint(x_TL,x_TR) #Randomize the cut point on x-axis
                if x_Cut%2 != 0 : #Check is the cut point is path
                    if x_Cut == x_TR:
                        x_Cut=x_Cut-1 #Making sure the cut point is even(wall) and within the chunk
                    else:
                        x_Cut=x_Cut+1 #Making sure the cut point is even(wall)
                x=x_Cut
                for y in range(y_BL,y_TL+1):
                    Board[x][y]="X" #Cut the chunk vertically
                y_Cut=random.randint(y_BL,y_TL) #Randomize the cut point on y-axis
                if y_Cut%2 != 0 : #Check is the cut point is path
                    if y_Cut == y_TL:
                        y_Cut=y_Cut-1 #Making sure the cut point is even(wall) and within the chunk
                    else:
                        y_Cut=y_Cut+1 #Making sure the cut point is even(wall)
                y=y_Cut
                for x in range(x_TL,x_TR+1):
                    Board[x][y]="X" #Cut the chunk horizontally
                Third_Hole=random.randint(0,1) #Randomize which axis will have two holes
                if Third_Hole == 0: #X-axis has two holes, Y-axis has one holes
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_TL,x_Cut) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x-1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_Cut,x_TR) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x+1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x-1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_BL,y_TL) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y-1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                elif Third_Hole == 1: #X-axis has one holes, Y-axis has two holes
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_TL,x_TR) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x-1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_BL,y_Cut) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y-1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_Cut,y_TL) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y+1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y-1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                Chunk_TL_N=Chunk_TL #Update the top left corner of the chunk
                x_TR=x_Cut-1 #Update the top right corner of the chunk
                Chunk_TR_N=grid(x_TR,y_TR)
                y_BL=y_Cut+1 #Update the bottom left corner of the chunk
                Chunk_BL_N=grid(x_BL,y_BL)
                x_BR=x_Cut-1 #Update the bottom right corner of the chunk
                y_BR=y_Cut+1
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk[0]=Chunk_TL_N #Store the updated chunk
                Chunk[1]=Chunk_TR_N
                Chunk[2]=Chunk_BL_N
                Chunk[3]=Chunk_BR_N
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                Chunk_TL_N=grid(x_TL,y_TL)
                Chunk_TR_N=Chunk_TR #Store the top right corner of the new chunk
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                y_BL=y_Cut+1
                Chunk_BL_N=grid(x_BL,y_BL)
                y_BR=y_Cut+1 #Store the bottom right corner of the new chunk
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                y_TL=y_Cut-1 #Store the top left corner of the new chunk
                Chunk_TL_N=grid(x_TL,y_TL)
                x_TR=x_Cut-1 #Store the top right corner of the new chunk
                y_TR=y_Cut-1
                Chunk_TR_N=grid(x_TR,y_TR)
                Chunk_BL_N=Chunk_BL #Store the bottom left corner of the new chunk
                x_BR=x_Cut-1 #Store the bottom right corner of the new chunk
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                y_TL=y_Cut-1
                Chunk_TL_N=grid(x_TL,y_TL)
                y_TR=y_Cut-1 #Store the top right corner of the new chunk
                Chunk_TR_N=grid(x_TR,y_TR)
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                Chunk_BL_N=grid(x_BL,y_BL)
                Chunk_BR_N=Chunk_BR #Store the bottom right corner of the new chunk
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
            if Chunk_num_F == Chunk_num: #Check is all chunk is finished
                Done=True
    y=Size-1
    Plot=False
    while not(Plot): #Randomize the player position
        x=random.randint(1,(Size-1))
        if x%2 == 0 :
            x=(x%2)+(x//2)+1
            x=x*random.randint(1,2)
            if x%2 == 0 :
                x=x+1
        if not(x >= Size):
            if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the player is start at the end of the path
                Plot=True
    Board[x][y]="P" #Player starting point
    y=0
    Plot=False
    while not(Plot): #Randomize the exit position
        x=random.randint(1,(Size-1))
        if x%2 == 0 :
            x=(x%2)+(x//2)+1
            x=x*random.randint(1,2)
            if x%2 == 0 :
                x=x+1
        if not(x >= Size):
            if Board[x-1][y+1] == "X" or Board[x+1][y+1] == "X": #Making sure the exit is at the end of the path
                Plot=True
    Board[x][y]="E" #Exit point
    print("System: Maze 0"+mn+" loaded successfully")
    maze_solve()

def check_state(Maze,Not_Maze,Done): #Loop-erased random walk method debug function
    global temp_Maze
    global temp_Not_Maze
    global temp_Done
    temp_Maze=Maze
    temp_Not_Maze=Not_Maze
    temp_Done=Done
    
def print_state(): #Loop-erased random walk method debug function
    print("")
    print_board()
    print("")
    print("System: Printing maze state...")
    print("Maze:")
    for y in range(int((Size-1)/2)):
        print(*[temp_Maze[x][int((Size-1)/2)-y-1] for x in range(int((Size-1)/2))])
    print("Not Maze:"+ str(temp_Not_Maze))
    print("Done:", temp_Done)

def grid(x,y): #Convert Location vector to Grid format
    #Grid format: Location vector in "0519" form, x=5 y=19
    if x<10:
        temp="0"+str(x)
    else:
        temp=str(x)
    if y<10:
        temp=temp+"0"+str(y)
    else:
        temp=temp+str(y)
    return temp

def maze_solve():
    global Board
    global Size
    global Difficulty
    global rec_step
    retry_cycle=0
    passed = False
    while not (passed):
        print("System: Calculating recommended steps...")
        rec_step=0
        i=1
        if i == 1: #Depth-First Search(DFS)
            Path=[] #Store the walked path in grid format
            Junctions=[] #Store the junctions in grid format
            Junction3=[] #Store the junctions that got 3 exit in grid format
            reach=False #Register is the exit reached
            found=False #Register is the player position found
            x=1
            y=Size-1
            while found != True: #Automated relocate player position
                    if Board[x][y] == "P":
                        found=True
                    else:
                        x=x+1
                        if x > (Size-1):
                            print("System: ERROR")
                            print("System: Player position not found, please restart the game")
                            input("System: Press Enter to exit the game ")
                            sys.exit()
            y=y-1
            rec_step=rec_step+1
            Board[x][y]="0"
            Path.append(grid(x,y))
            while not(reach): #Check is the exit reached
                exit_way=[] #Direction of walkable path
                exit_num=0 #Number of walkable path
                direction=None #Direction of walk
                if Board[x][y-1] == "E": #Check is the bottom box the exit
                    rec_step=rec_step+1
                    reach=True
                elif Board[x][y-1] == " ": #Check is the bottom box the path
                    exit_num=exit_num+1
                    exit_way.append("down")
                if Board[x-1][y] == " ": #Check is the left box the path
                    exit_num=exit_num+1
                    exit_way.append("left")
                if Board[x][y+1] == " ": #Check is the top box the path
                    exit_num=exit_num+1
                    exit_way.append("up")
                if Board[x+1][y] == " ": #Check is the right box the path
                    exit_num=exit_num+1
                    exit_way.append("right")
                if exit_num == 1: #One-way path
                    direction=0
                elif exit_num == 2: #2-way junction
                    Junctions.append(grid(x,y))
                    direction=random.randint(0,1) #Random choose a way to walk
                elif exit_num == 3: #3-way junction
                    Junctions.append(grid(x,y))
                    Junction3.append(grid(x,y))
                    direction=random.randint(0,2) #Random choose a way to walk
                if reach != True:
                    if direction != None:
                        if exit_way[direction] == "up": #Walk up
                            y=y+1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "down": #Walk down
                            y=y-1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "left": #Walk left
                            x=x-1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "right": #Walk right
                            x=x+1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                    elif (direction == None) and (exit_num == 0): #Dead end
                        back=False
                        while not(back): #Check did it arrive the previous junction
                            Board[x][y]="/"
                            Path.pop()
                            rec_step=rec_step-1
                            temp=Path[len(Path)-1] #Move back
                            x=int(temp[0:2])
                            y=int(temp[2:4])
                            if len(Junction3) != 0: #Check is there any 3-way junction
                                if temp == Junction3[len(Junction3)-1]: #Check is it at the 3-way junction
                                    Junction3.pop()
                                    back=True
                            if back != True:
                                if temp == Junctions[len(Junctions)-1]: #Check is it at the junction
                                    Junctions.pop()
                                    back=True
                #print_board() #Debugging output
                #print("rec_step: "+ str(rec_step)) #Debugging output
                #print("Junctions: "+ str(Junctions)) #Debugging output
                #print("Junction3: "+ str(Junction3)) #Debugging output
                #print("exit_way: "+ str(exit_way)) #Debugging output
                #print("exit_num: "+ str(exit_num)) #Debugging output
                #print("direction: "+ str(direction)) #Debugging output
                #print("Path: "+ str(Path)) #Debugging output
            x=1
            y=0
            while (x != Size-2) or (y != Size-2): #Cleaning up the board
                if y+1 == Size-1: #Check did it reach the top
                    y=1
                    x=x+1
                else:
                    y=y+1
                if Board[x][y] != "X": #Replace the path
                    Board[x][y]=" "
        elif i == 2: #Breadth-First Search(BFS)
            None
        elif i == 3: #A* Search
            None
        min_step=Size*Size*0.1 #Minimum steps for the maze
        if rec_step <= min_step: #Make sure the recommended steps is not too low
            for k in range(Size): #Redraw the top and bottom edge
                        Board[k][0] = "X"
                        Board[k][Size-1] = "X"
            y=Size-1
            Plot=False
            while not(Plot): #Randomize the player position
                x=random.randint(1,(Size-1))
                if x%2 == 0 :
                    x=(x%2)+(x//2)+1
                    x=x*random.randint(1,2)
                    if x%2 == 0 :
                        x=x+1
                if not(x >= Size):
                    if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the player is start at the end of the path
                        Plot=True
            Board[x][y]="P" #Player starting point
            y=0
            Plot=False
            while not(Plot): #Randomize the exit position
                x=random.randint(1,(Size-1))
                if x%2 == 0 :
                    x=(x%2)+(x//2)+1
                    x=x*random.randint(1,2)
                    if x%2 == 0 :
                        x=x+1
                if not(x >= Size):
                    if Board[x-1][y+1] == "X" or Board[x+1][y+1] == "X": #Making sure the exit is at the end of the path
                        Plot=True
            Board[x][y]="E" #Exit point
            retry_cycle=retry_cycle+1
            if retry_cycle == 3: #Maximum number of retry
                build_maze() #Restart the maze generation if it exceed the maximum number of retry
        else:
            passed=True
    rec_step=rec_step+10 #Add some buffer to the recommended steps
    print("System: Recommend steps for this maze:", rec_step)
    game()

def main():
    global Size
    global Board
    global steps
    global Type_error
    global Difficulty
    steps=0
    Type_error=False
    print("System: This game is for single players")
    time.sleep(1)
    print("System: The icon 'X' represent the wall, and icon ' ' represent the path")
    time .sleep(1)
    print("System: Icon 'P' is the player, and icon 'E' is the exit")
    time.sleep(1)
    print("System: You can move in four directions")
    time.sleep(1)
    print("System: Up(W), Down(S), Left(A), Right(D)")
    time.sleep(1)
    print("System: Single character is entered everytime")
    time.sleep(1)
    print("System: Every steps you take will be recorded")
    time.sleep(1)
    print("System: Your goal is to exit the maze with fewest steps")
    time.sleep(1)
    print("System: In Hardcore Mode your steps was limmited, think carefully before moving")
    time.sleep(1)
    print("System: You are not allow to use more steps than the system recommended in Hardcore Mode")
    time.sleep(1)
    ans=input("System: Press Enter to start the game ")
    passed=False
    while not passed:
        try:
            ans=int(input("System: Please enter difficulty: 1(21*21 Board), 2(31*31 Board), 3(41*41 Board), 4(51*51 Board), 5(Hardcore Mode) "))
            if ans <=0 or ans > 5:
                print("System: Out of bounds")
            elif ans == 5:
                passed=False
                ans=4
                Difficulty=5
                print("System: Hardcore mode is not available now")
            else:
                passed=True
                Difficulty=ans
        except:
            print("System: Formet error")
    Size=(ans+1)*10+1
    print("System: Good luck!")
    time.sleep(0.5)
    build_maze()

import time
import random
import sys
main()
