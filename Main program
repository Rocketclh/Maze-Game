def main():
    global steps
    global Board
    global Size
    global Test
    global Type_error
    if Type_error:
        Type_error=False
    else:
        print_board()
    found=False
    x=0
    y=0
    while found != True: #Automated relocate player position
        if Board[x][y] == "P":
            found=True
        else:
            y=y+1
            if y > (Size-1):
                x=x+1
                y=0
                if x > (Size-1):
                    print("System: ERROR")
                    print("System: Player position not found, please restart the game")
                    ans=input("System: Press Enter to exit the game")
                    sys.exit()
    ans=input("System: Please enter the direction you want to move")
    ans=ans.lower()
    if ans == "w": #Move up
        if y < (Size-1) and Board[x][y+1] != "X":
            Board[x][y]=" "
            y=y+1
            steps=steps+1
            if Board[x][y] == "E":
                end()
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move up")
            Type_error=True
            main()
    elif ans == "s": #Move down
        if y > 0 and Board[x][y-1] != "X":
            Board[x][y]=" "
            y=y-1
            steps=steps+1
            if Board[x][y] == "E":
                end()
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move down")
            Type_error=True
            main()
    elif ans == "a": #Move left
        if x > 0 and Board[x-1][y] != "X":
            Board[x][y]=" "
            x=x-1
            steps=steps+1
            if Board[x][y] == "E":
                end()
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move left")
            Type_error=True
            main()
    elif ans == "d": #Move right
        if x < (Size-1) and Board[x+1][y] != "X":
            Board[x][y]=" "
            x=x+1
            steps=steps+1
            if Board[x][y] == "E":
                end()
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move right")
            Type_error=True
            main()
    else:
        print("System: Invalid input!")
        print("System: Please enter W, A, S, or D")
        Type_error=True
        main()
    main()

def end():
    global steps
    print("System: Congratulations!")
    print("System: You have exited the maze!")
    print("System: Total steps taken:", steps)
    ans=input("System: Press Enter to exit the game")
    sys.exit()

def print_board(): #0,0 at bottem left corner
    global Board
    print("")
    for y in range(Size):
        print(*[Board[x][Size-y-1] for x in range(Size)])

def build_maze():
    global Board
    global Difficulty 
    global Size
    global Test
    i=3 #Maze generation method
    if i == 1: #Manual method
        Board=[[" "] * 21 for n in range(21)]
        print("System: Loading Maze 01...")
        time.sleep(0.1)
        x=0 
        y=0
        for j in range(9):
            Board[x][y]="X"
            x=x+1
        Board[x][y]="P"  #Player starting point
        x=x+1
        for j in range(11):
            Board[x][y]="X"
            x=x+1
        x=0 
        y=1
        Board[x][y]="X"
        x=x+6
        Board[x][y]="X"
        x=x+12
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=0 
        y=2
        Board[x][y]="X"
        x=x+2
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1 
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=x+2
        for j in range(7):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=0
        y=3
        Board[x][y]="X"
        for j in range(4):
            x=x+2
            Board[x][y]="X"
        for j in range(3):
            x=x+4
            Board[x][y]="X"
        x=0
        y=4
        Board[x][y]="X"
        for j in range(3):
            x=x+2
            Board[x][y]="X"
        x=x+2
        for j in range(2):
            Board[x][y]="X"
            x=x+1
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=x+2
        for j in range(7):
            Board[x][y]="X"
            x=x+1
        x=0
        y=5
        Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        for j in range(5):
            x=x+2
            Board[x][y]="X"
        x=x+6
        Board[x][y]="X"
        x=0
        y=6
        for j in range(5):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(5):
            Board[x][y]="X"
            x=x+2
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=0
        y=7
        Board[x][y]="X"
        x=x+4
        for j in range(6):
            Board[x][y]="X"
            x=x+2
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=0
        y=8
        Board[x][y]="X"
        for j in range(6):
            x=x+2
            Board[x][y]="X"
        x=x+2
        for j in range(5):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=0
        y=9
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=x+10
        Board[x][y]="X"
        x=x+4
        x=0
        y=10
        Board[x][y]="X"
        x=x+2
        for j in range(5):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(2):
            Board[x][y]="X"
            x=x+2
        for j in range(5):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=0
        y=11
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        for j in range(2):
            x=x+4
            Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=0
        y=12
        Board[x][y]="X"
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=x+2
        for j in range(5):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=x+2
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=0
        y=13
        Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        x=x+6
        Board[x][y]="X"
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=0
        y=14
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(5):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(3):
            Board[x][y]="X"
            x=x+2
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=0
        y=15
        Board[x][y]="X"
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=x+6
        for j in range(4):
            Board[x][y]="X"
            x=x+2
        x=x+2
        Board[x][y]="X"
        x=0
        y=16
        Board[x][y]="X"
        for j in range(2):
            x=x+2
            Board[x][y]="X"
        x=x+2
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(4):
            Board[x][y]="X"
            x=x+2
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=0
        y=17
        Board[x][y]="X"
        for j in range(2):
            x=x+4
            Board[x][y]="X"
        x=x+6
        Board[x][y]="X"
        x=x+2
        Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        x=0
        y=18
        for j in range(7):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(7):
            Board[x][y]="X"
            x=x+1
        x=x+1
        for j in range(3):
            Board[x][y]="X"
            x=x+1
        x=x+1
        Board[x][y]="X"
        x=0
        y=19
        Board[x][y]="X"
        x=x+10
        Board[x][y]="X"
        x=x+6
        Board[x][y]="X"
        x=x+4
        Board[x][y]="X"
        x=0 
        y=20
        for j in range(11):
            Board[x][y]="X"
            x=x+1
        Board[x][y]="E"  #Exit point
        x=x+1
        for j in range(9):
            Board[x][y]="X"
            x=x+1
        print("System: Maze 01 loaded successfully.")
    elif i == 2: #Loop-erased random walk method
        #Maze format: node only
        #Board format: node and line(path)
        Board=[["X"] * Size for i in range(Size)]
        mn=str(random.randint(1,999)) #Random generate maze ID
        print("System: Loading Maze 0"+mn+"...")
        time.sleep(0.1)
        x=1
        y=1
        Board[x][y]=" "
        Maze=[["F"] * int((Size-1)/2) for n in range(int((Size-1)/2))] #Store the cell that are part of the maze, grid is stored in node form, lines are not included
        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
        y=int((x+1)/2-1)
        Maze[x][y]="T"
        Done=False #Register maze is fully finished
        while not(Done): #Check is all node included in the maze
            Done=True
            Not_Maze=[] #The cell that are not part of the maze, 1D array, in maze format
            for h in range(0,len(Maze)): #x-axis
                for v in range(0,len(Maze)): #y-axis
                    if Maze[h][v] == "F": #Check is it part of maze
                        Done=False
                        if h<10:
                            temp="0"+str(h)
                        else:
                            temp=str(h)
                        if v<10:
                            temp=temp+"0"+str(v)
                        else:
                            temp=temp+str(v)
                        Not_Maze.append(temp) #Storing the grid in "0519" form as x=5 y=19
            if not Done:
                temp=Not_Maze[random.randint(0,len(Not_Maze)-1)] #In Maze format
                x=int(temp[0:2])
                y=int(temp[2:4])
                x=2*x+1 #Converting location vector from Maze format to Board format
                y=2*y+1
                Path=[temp] #Stored walked path, in Board format
                while Maze[int((x+1)/2-1)][int((y+1)/2-1)] != "T":
                    retry=False
                    Direction=random.randint(1,4) #1:Up 2:Down 3:Left 4:Right
                    Steps=random.randint(1,2)*2
                    if Direction == 1: #Move up
                        if y+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                if x<10:
                                    temp="0"+str(x)
                                else:
                                    temp=str(x)
                                y=y+1
                                if y<10:
                                    temp=temp+"0"+str(y)
                                else:
                                    temp=temp+str(y)
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == temp:
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(temp) #Storing the grid in "0519" form as x=5 y=19
                    elif Direction == 2: #Move down
                        if y-Steps <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                if x<10:
                                    temp="0"+str(x)
                                else:
                                    temp=str(x)
                                y=y-1
                                if y<10:
                                    temp=temp+"0"+str(y)
                                else:
                                    temp=temp+str(y)
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == temp:
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(temp) #Storing the grid in "0519" form as x=5 y=19
                    elif Direction == 3: #Move left
                        if (x-Steps) <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x-1
                                if x<10:
                                    temp="0"+str(x)
                                else:
                                    temp=str(x)
                                if y<10:
                                    temp=temp+"0"+str(y)
                                else:
                                    temp=temp+str(y)
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == temp:
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(temp) #Storing the grid in "0519" form as x=5 y=19
                    elif Direction == 4: #Move right
                        if x+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x+1
                                if x<10:
                                    temp="0"+str(x)
                                else:
                                    temp=str(x)
                                if y<10:
                                    temp=temp+"0"+str(y)
                                else:
                                    temp=temp+str(y)
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == temp:
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(temp) #Storing the grid in "0519" form as x=5 y=19
                for n in range(0, len(Path)-1): #Register paths into maze
                    temp=Path[n] #Load grid into temp, in Board format
                    x=int(temp[0:2])
                    y=int(temp[2:4])
                    Board[x][y]=" "
                    if n%2 == 0 :
                        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
                        y=int((y+1)/2-1)
                        Maze[x][y]="T"
                check_state(Maze,Not_Maze,Done)
                for k in range(Size): #Redraw the edge
                    Board[0][k] = "X"
                    Board[Size-1][k] = "X"
                    Board[k][0] = "X"
                    Board[k][Size-1] = "X"
        Board[1][Size-1]="P"  #Player starting point on top left corner
        y=0
        Plot=False
        while not(Plot): #Randomize the exit position
            x=random.randint(1,(Size-1))
            if x%2 == 0 :
                x=(x%2)+(x//2)+1
                x=x*random.randint(1,2)
                if x%2 == 0 :
                    x=x+1
                if not(x>Size):
                    if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the exit is at the end of the path
                        Plot=True
        Board[x][y]="E"  #Exit point
        print("System: Maze 0"+mn+" loaded successfully.")
    elif i == 3: #Recursive division method
        mn=str(random.randint(1,999)) #Random generate maze ID
        print("System: Loading Maze 0"+mn+"...")
        for k in range(Size): #Redraw the edge
            Board[0][k] = "X"
            Board[Size-1][k] = "X"
            Board[k][0] = "X"
            Board[k][Size-1] = "X"
        Chunk=[] #Store the chunks, each chunck stored in oreder of Top left corner, Top right corner, Bottom left corner, Bottom right corner grid
        Chunk_num=0 #Number of chunks
        Chunk_num_F=0 #Number of chunks that are fully finished
        for n in range(0,4):
            if n == 0: #Top left corner of the chunk
                x=1
                y=Size-2
            elif n == 1: #Top right corner of the chunk
                x=Size-2
                y=Size-2
            elif n == 2: #Bottom left corner of the chunk
                x=1
                y=1
            elif n == 3: #Bottom right corner of the chunk
                x=Size-2
                y=1
            if x<10:
                temp="0"+str(x)
            else:
                temp=str(x)
            if y<10:
                temp=temp+"0"+str(y)
            else:
                temp=temp+str(y)
            Chunk.append(temp) #Storing the grid in "0519" form as x=5 y=19
        Chunk_num=Chunk_num+1
        Done = False #Register maze is fully finished
        while not(Done): #Check is the maze finished
            Chunk_TL=Chunk[0] #Top left corner of the chunk
            Chunk_TR=Chunk[1] #Top right corner of the chunk
            Chunk_BL=Chunk[2] #Bottom left corner of the chunk
            Chunk_BR=Chunk[3] #Bottom right corner of the chunk
            x_TL=int(Chunk_TL[0:2]) #Converting grid to location vector (x), path
            y_TL=int(Chunk_TL[2:4]) #Converting grid to location vector (y), path
            x_TR=int(Chunk_TR[0:2])
            y_TR=int(Chunk_TR[2:4])
            x_BL=int(Chunk_BL[0:2])
            y_BL=int(Chunk_BL[2:4])
            x_BR=int(Chunk_BR[0:2])
            y_BR=int(Chunk_BR[2:4])
            if (x_TL == x_TR) or (y_TL == y_BL): #Check is the chunk is too small
                Chunk_num_F=Chunk_num_F+1 #Update the number of chunks that are fully finished
                Chunk.pop(0,1,2,3) #Remove the completed chunk
            else:
                x_Cut=random.randint(x_TL+1,x_TR-1) #Randomize the cut point, even number is path, odd number is node
                if x_Cut%2 != 0 : #Check is the cut point is path
                    x_Cut=x_Cut+1 #Making sure the cut point is node
                x=x_Cut
                for y in range(y_BL,y_TL+1):
                    Board[x][y]="X" #Cut the chunk vertically
                y=random.randint(y_BL,y_TL) #Randomlize the hole point, even number is node, odd number is path
                if y%2 != 0 : #Check is the hole point is node
                    y=y+1 #Making sure the hole point is path
                Board[x][y]=" " #Making the hole in the wall
                time.sleep(0.001)
                y_Cut=random.randint(y_BL-1,y_TL+1) #Randomize the cut point, even number is path, odd number is node
                if y_Cut%2 == 0 : #Check is the cut point is path
                    y_Cut=y_Cut+1 #Making sure the cut point is node
                y=y_Cut
                for x in range(x_TL,x_TR+1):
                    Board[x][y]="X" #Cut the chunk horizontally
                y=random.randint(x_TL,x_TR) #Randomlize the hole point, even number is node, odd number is path
                if y%2 == 0 : #Check is the hole point is node
                    y=y+1 #Making sure the hole point is path
                Board[x][y]=" "
                Chunk_TL_N=Chunk_TL #Update the top left corner of the chunk
                x_TR=x_Cut-1 #Update the top right corner of the chunk
                if x_TR<10:
                    temp="0"+str(x_TR)
                else:
                    temp=str(x_TR)
                if y_TR<10:
                    temp=temp+"0"+str(y_TR)
                else:
                    temp=temp+str(y_TR)
                Chunk_TR_N=temp
                y_BL=y_Cut+1 #Update the bottom left corner of the chunk
                if x_BL<10:
                    temp="0"+str(x_BL)
                else:
                    temp=str(x_BL)
                if y_BL<10:
                    temp=temp+"0"+str(y_BL)
                else:
                    temp=temp+str(y_BL)
                Chunk_BL_N=temp
                x_BR=x_Cut-1 #Update the bottom right corner of the chunk
                y_BR=y_Cut+1
                if x_BR<10:
                    temp="0"+str(x_BR)
                else:
                    temp=str(x_BR)
                if y_BR<10:
                    temp=temp+"0"+str(y_BR)
                else:
                    temp=temp+str(y_BR)
                Chunk_BR_N=temp
                Chunk[0]=Chunk_TL_N #Store the updated chunk
                Chunk[1]=Chunk_TR_N
                Chunk[2]=Chunk_BL_N
                Chunk[3]=Chunk_BR_N
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                if x_TL<10:
                    temp="0"+str(x_TL)
                else:
                    temp=str(x_TL)
                if y_TL<10:
                    temp=temp+"0"+str(y_TL)
                else:
                    temp=temp+str(y_TL)
                Chunk_TL_N=temp
                Chunk_TR_N=Chunk_TR #Store the top right corner of the new chunk
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                y_BL=y_Cut+1
                if x_BL<10:
                    temp="0"+str(x_BL)
                else:
                    temp=str(x_BL)
                if y_BL<10:
                    temp=temp+"0"+str(y_BL)
                else:
                    temp=temp+str(y_BL)
                Chunk_BL_N=temp
                y_BR=y_Cut+1 #Store the bottom right corner of the new chunk
                if x_BR<10:
                    temp="0"+str(x_BR)
                else:
                    temp=str(x_BR)
                if y_BR<10:
                    temp=temp+"0"+str(y_BR)
                else:
                    temp=temp+str(y_BR)
                Chunk_BR_N=temp
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                y_TL=y_Cut-1 #Store the top left corner of the new chunk
                if y_TL<10:
                    temp="0"+str(y_TL)
                else:
                    temp=str(y_TL)
                if x_TL<10:
                    temp=temp+"0"+str(x_TL)
                else:
                    temp=temp+str(x_TL)
                Chunk_TL_N=temp
                x_TR=x_Cut-1 #Store the top right corner of the new chunk
                y_TR=y_Cut-1
                if x_TR<10:
                    temp="0"+str(x_TR)
                else:
                    temp=str(x_TR)
                if y_TR<10:
                    temp=temp+"0"+str(y_TR)
                else:
                    temp=temp+str(y_TR)
                Chunk_TR_N=temp
                Chunk_BL_N=Chunk_BL #Store the bottom left corner of the new chunk
                x_BR=x_Cut-1 #Store the bottom right corner of the new chunk
                if x_BR<10:
                    temp="0"+str(x_BR)
                else:
                    temp=str(x_BR)
                if y_BR<10:
                    temp=temp+"0"+str(y_BR)
                else:
                    temp=temp+str(y_BR)
                Chunk_BR_N=temp
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                y_TL=y_Cut-1
                if x_TL<10:
                    temp="0"+str(x_TL)
                else:
                    temp=str(x_TL)
                if y_TL<10:
                    temp=temp+"0"+str(y_TL)
                else:
                    temp=temp+str(y_TL)
                Chunk_TL_N=temp
                y_TL=y_Cut-1 #Store the top right corner of the new chunk
                if x_TR<10:
                    temp="0"+str(x_TR)
                else:
                    temp=str(x_TR)
                if y_TL<10:
                    temp=temp+"0"+str(y_TL)
                else:
                    temp=temp+str(y_TL)
                Chunk_TL_N=temp
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                if x_BL<10:
                    temp="0"+str(x_BL)
                else:
                    temp=str(x_BL)
                if y_BL<10:
                    temp=temp+"0"+str(y_BL)
                else:
                    temp=temp+str(y_BL)
                Chunk_BL_N=temp
                Chunk_BR_N=Chunk_BR #Store the bottom right corner of the new chunk
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
            if Chunk_num_F == Chunk_num: #Check is all chunk is finished
                Done=True
        Board[1][Size-1]="P"  #Player starting point on top left corner
        y=0
        Plot=False
        while not(Plot): #Randomize the exit position
            x=random.randint(1,(Size-1))
            if x%2 == 0 :
                x=(x%2)+(x//2)+1
                x=x*random.randint(1,2)
                if x%2 == 0 :
                    x=x+1
                if not(x>Size):
                    if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the exit is at the end of the path
                        Plot=True
        Board[x][y]="E"  #Exit point
        print("System: Maze 0"+mn+" loaded successfully.")

    main()

def check_state(Maze,Not_Maze,Done):
    global temp_Maze
    global temp_Not_Maze
    global temp_Done
    temp_Maze=Maze
    temp_Not_Maze=Not_Maze
    temp_Done=Done
    
def print_state():
    print("")
    print_board()
    print("")
    print("System: Printing maze state...")
    print("Maze:")
    for y in range(int((Size-1)/2)):
        print(*[temp_Maze[x][int((Size-1)/2)-y-1] for x in range(int((Size-1)/2))])
    print("Not Maze:"+ str(temp_Not_Maze))
    print("Done:", temp_Done)

import time
import random
import sys
steps=0
Type_error=False
Test=False
print("System: This game is for single players")
time.sleep(1)
print("System: Icon'X' is the wall, and icon ' ' is the path")
time .sleep(1)
print("System: Icon 'P' represent player, and icon 'E' represent exit")
time.sleep(1)
print("System: You can move in four directions")
time.sleep(1)
print("System: Up (W), Down (S), Left (A), Right (D)")
time.sleep(1)
print("System: Every steps you take will be recorded")
time.sleep(1)
print("System: Your goal is to exit the maze with fewest steps")
time.sleep(1)
print("System: In Hardcore Mode your steps was limmited, think carefully before moving")
time.sleep(1)
ans=input("System: Press Enter to start the game")
if ans == "/test":
    test=True
passed=False
while not passed:
    try:
        ans=int(input("System: Please enter difficulty  1(21*21 Board), 2(31*31 Board), 3(41*41 Board), 4(51*51 Board), 5(Hardcore Mode)"))
        if ans <=0 or ans > 5:
            print("System: Out of bounds")
        elif ans == 5:
            ans=4
        else:
            passed=True
    except:
        print("System: Formet error")
Difficulty =(ans+1)*5
Size=Difficulty *2+1
Board=[[" "] * Size for i in range(Size)]
print("System: Good luck!")
time.sleep(0.5)
build_maze()
