def game(): #CLI game control
    global steps
    global Board
    global Size
    global Type_error
    global Difficulty
    global rec_step
    global Time_up
    if Type_error:
        Type_error=False
    else:
        print_board()
    temp=player_found() #Found player location
    x=int(temp[0:2])
    y=int(temp[2:4])
    if Difficulty == 5:
        if steps == rec_step:
            end(False)
    ans=input("System: Please enter the direction you want to move ")
    ans=ans.lower()
    if Difficulty != 5 or not(Time_up): #Time up check for Hard mode
        if ans == "w": #Move up
            if y < (Size-1) and Board[x][y+1] != "X":
                Board[x][y]=" "
                y=y+1
                steps=steps+1
                if Board[x][y] == "E":
                    end(True)
                else:
                    Board[x][y]="P"
            else:
                print("System: Invalid move!")
                print("System: You cannot move up")
                Type_error=True
                time.sleep(0.5)
        elif ans == "s": #Move down
            if y > 0 and Board[x][y-1] != "X":
                Board[x][y]=" "
                y=y-1
                steps=steps+1
                if Board[x][y] == "E":
                    end(True)
                else:
                    Board[x][y]="P"
            else:
                print("System: Invalid move!")
                print("System: You cannot move down")
                Type_error=True
                time.sleep(0.5)
        elif ans == "a": #Move left
            if x > 0 and Board[x-1][y] != "X":
                Board[x][y]=" "
                x=x-1
                steps=steps+1
                if Board[x][y] == "E":
                    end(True)
                else:
                    Board[x][y]="P"
            else:
                print("System: Invalid move!")
                print("System: You cannot move left")
                Type_error=True
                time.sleep(0.5)
        elif ans == "d": #Move right
            if x < (Size-1) and Board[x+1][y] != "X":
                Board[x][y]=" "
                x=x+1
                steps=steps+1
                if Board[x][y] == "E":
                    end(True)
                else:
                    Board[x][y]="P"
            else:
                print("System: Invalid move!")
                print("System: You cannot move right")
                Type_error=True
                time.sleep(0.5)
        elif len(ans) != 1:
            print("System: Out of Range!")
            print("System: Please enter single character")
            Type_error=True
            time.sleep(0.5)
        else:
            print("System: Invalid input!")
            print("System: Please enter 'W', 'A', 'S', or 'D'")
            Type_error=True
            time.sleep(0.5)
        game()

def end(win): #win output
    global steps
    global rec_step
    global mode
    global screen
    global pen
    global Time_up
    global Exit_bt
    global Restart_bt
    global page
    global player
    global Minutes
    global Second
    if mode == 1: #CLI end output
        if win:
            print("System: Congratulations!")
            print("System: You have exited the maze!")
            print("System: Total steps taken:", steps)
            print("System: Maze recommended steps:", rec_step)
        else:
            print("System: Game Over")
            print("System: You have used all of the steps")
            print("System: Total steps taken:", steps)
            print("System: Maze recommended steps:", rec_step)
        time.sleep(0.5)
        ans=input("System: Press Enter to exit the game or type '/restart' to restart the game ")
        if ans.lower() == "/restart":
            for i in range(5):
                print("")
            Menu_CLI()
        else:
            sys.exit()
    elif mode == 2: #GUI end output
        page=5
        screen.clear() #Clear screen
        screen.setup(width=550, height=650)
        screen.tracer(0)
        screen.update()
        pen.clear() #Reset pen
        pen.penup()
        player.hideturtle()
        screen.update()
        style="Arial", 25, "bold"
        y=100
        if win:
            pen.goto(0,y)
            pen.write("Congratulations!", align="center", font=(style))
            y=y-50
            pen.goto(0,y)
            pen.write("You have exited the maze!", align="center", font=(style))
        else:
            pen.goto(0,y)
            pen.write("Game Over", align="center", font=(style))
            y=y-50
            pen.goto(0,y)
            if Time_up: #Times up
                pen.write("You ran out of time", align="center", font=(style))
            else:
                pen.write("You have used all of the steps", align="center", font=(style))
        y=y-50
        pen.goto(0,y)
        text="Total steps taken:"+str(steps)
        pen.write(text, align="center", font=(style))
        y=y-50
        pen.goto(0,y)
        text="Maze recommended steps:"+str(rec_step)
        pen.write(text, align="center", font=(style))
        y=y-50
        pen.goto(0,y)
        text="Time spend:"+str(Minutes)+" minutes "+str(Second)+" seconds"
        pen.write(text, align="center", font=(style))
        y=y-50
        pen.goto(-200,y)
        Restart_bt=Button(-175,y,200,50,"Restart",style)
        Restart_bt.draw()
        pen.goto(50,y)
        Exit_bt=Button(50,y,150,50,"Exit",style)
        Exit_bt.draw()
        screen.update()
        screen.onclick(button_click)
        screen.onkeypress(None,"w")
        screen.onkeypress(None,"s")
        screen.onkeypress(None,"a")
        screen.onkeypress(None,"d")
        screen.listen()

def print_board(): # board
    global Board
    global Size
    print("")
    for y in range(Size): #0,0 at bottem left corner
        h=Size-y-1 #Height of the board
        if h<10:
            temp="0"+str(h)
        else:
            temp=str(h)
        print(temp, *[Board[x][h] for x in range(Size)])
    print("")

def build_maze():
    global Board
    global Size
    global mode
    global mn
    mn=str(random.randint(1,999)) #Random generate maze ID
    if mode == 1:
        print("System: Loading Maze 0"+mn+"...")
    Method=2 #Maze generation method using
    if Method == 1: #Loop-erased random walk method
        #Maze format: node only
        #Board format: node, path and wall
        #Grid format: Location vector in "0519" form, x=5 y=19
        Board=[["X"] * Size for z in range(Size)]
        x=1
        y=1
        Board[x][y]=" "
        Maze=[["F"] * int((Size-1)/2) for n in range(int((Size-1)/2))] #Store the cells that are part of the maze, stored in Maze format
        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
        y=int((x+1)/2-1)
        Maze[x][y]="T"
        Done=False #Register maze is fully finished
        while not(Done): #Check is all node included in the maze
            Done=True
            Not_Maze=[] #The cells that are not part of the maze, 1D array, stored in maze format
            for h in range(0,len(Maze)): #x-axis
                for v in range(0,len(Maze)): #y-axis
                    if Maze[h][v] == "F": #Check is it part of maze
                        Done=False
                        Not_Maze.append(grid(h,v)) #Storing the Location vector in Grid format
            if not Done:
                temp=Not_Maze[random.randint(0,len(Not_Maze)-1)] #In Maze format
                x=int(temp[0:2])
                y=int(temp[2:4])
                x=2*x+1 #Converting location vector from Maze format to Board format
                y=2*y+1
                Path=[temp] #Store walked path, stored in Board format
                while Maze[int((x+1)/2-1)][int((y+1)/2-1)] != "T":
                    retry=False
                    Direction=random.randint(1,4) #1:Up 2:Down 3:Left 4:Right
                    Steps=random.randint(1,2)*2
                    if Direction == 1: #Move up
                        if y+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                y=y+1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        m=c
                                        found=True
                                if found:
                                    Path = Path[:(m-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 2: #Move down
                        if y-Steps <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                y=y-1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        m=c
                                        found=True
                                if found:
                                    Path = Path[:(m-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 3: #Move left
                        if (x-Steps) <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x-1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        m=c
                                        found=True
                                if found:
                                    Path = Path[:(m-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 4: #Move right
                        if x+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x+1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        m=c
                                        found=True
                                if found:
                                    Path = Path[:(m-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                for n in range(0, len(Path)-1): #Register paths into maze
                    temp=Path[n] #Load grid into temp, in Board format
                    x=int(temp[0:2])
                    y=int(temp[2:4])
                    Board[x][y]=" "
                    if n%2 == 0 :
                        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
                        y=int((y+1)/2-1)
                        Maze[x][y]="T"
                check_state(Maze,Not_Maze,Done)
                for k in range(Size): #Redraw the edge
                    Board[0][k] = "X"
                    Board[Size-1][k] = "X"
                    Board[k][0] = "X"
                    Board[k][Size-1] = "X"
    elif Method == 2: #Recursive division method
        #Grid format: Location vector in "0519" form, x=5 y=19
        Board=[[" "] * Size for z in range(Size)]
        for k in range(Size): #Draw the edge
            Board[0][k] = "X"
            Board[Size-1][k] = "X"
            Board[k][0] = "X"
            Board[k][Size-1] = "X"
        Chunk=[] #Store the chunks, each chunk stored in order of Top left corner, Top right corner, Bottom left corner, Bottom right corner in Grid format
        Chunk_num=0 #Number of chunks
        Chunk_num_F=0 #Number of chunks that are fully finished
        for n in range(0,4):
            if n == 0: #Top left corner of the chunk
                x=1
                y=Size-2
            elif n == 1: #Top right corner of the chunk
                x=Size-2
                y=Size-2
            elif n == 2: #Bottom left corner of the chunk
                x=1
                y=1
            elif n == 3: #Bottom right corner of the chunk
                x=Size-2
                y=1
            Chunk.append(grid(x,y)) #Storing the Location vector in Grid format
        Chunk_num=Chunk_num+1
        Done = False #Register maze is fully finished
        while not(Done): #Check is the maze finished
            Chunk_TL=Chunk[0] #Top left corner of the chunk, stored in Grid format
            Chunk_TR=Chunk[1] #Top right corner of the chunk, stored in Grid format
            Chunk_BL=Chunk[2] #Bottom left corner of the chunk, stored in Grid format
            Chunk_BR=Chunk[3] #Bottom right corner of the chunk, stored in Grid format
            x_TL=int(Chunk_TL[0:2]) #Converting Grid format to location vector (x), path
            y_TL=int(Chunk_TL[2:4]) #Converting Grid format to location vector (y), path
            x_TR=int(Chunk_TR[0:2])
            y_TR=int(Chunk_TR[2:4])
            x_BL=int(Chunk_BL[0:2])
            y_BL=int(Chunk_BL[2:4])
            x_BR=int(Chunk_BR[0:2])
            y_BR=int(Chunk_BR[2:4])
            if (x_TL == x_TR) or (y_TL == y_BL): #Check is the chunk is too small
                Chunk_num_F=Chunk_num_F+1 #Update the number of chunks that are fully finished
                for n in range (0,4):
                    Chunk.pop(0) #Remove the completed chunk
            else:
                x_Cut=random.randint(x_TL,x_TR) #Randomize the cut point on x-axis
                if x_Cut%2 != 0 : #Check is the cut point is path
                    if x_Cut == x_TR:
                        x_Cut=x_Cut-1 #Making sure the cut point is even(wall) and within the chunk
                    else:
                        x_Cut=x_Cut+1 #Making sure the cut point is even(wall)
                x=x_Cut
                for y in range(y_BL,y_TL+1):
                    Board[x][y]="X" #Cut the chunk vertically
                y_Cut=random.randint(y_BL,y_TL) #Randomize the cut point on y-axis
                if y_Cut%2 != 0 : #Check is the cut point is path
                    if y_Cut == y_TL:
                        y_Cut=y_Cut-1 #Making sure the cut point is even(wall) and within the chunk
                    else:
                        y_Cut=y_Cut+1 #Making sure the cut point is even(wall)
                y=y_Cut
                for x in range(x_TL,x_TR+1):
                    Board[x][y]="X" #Cut the chunk horizontally
                Third_Hole=random.randint(0,1) #Randomize which axis will have two holes
                if Third_Hole == 0: #X-axis has two holes, Y-axis has one holes
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_TL,x_Cut) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x-1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_Cut,x_TR) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x+1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x-1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_BL,y_TL) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y-1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                elif Third_Hole == 1: #X-axis has one holes, Y-axis has two holes
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_TL,x_TR) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x-1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_BL,y_Cut) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y-1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_Cut,y_TL) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y+1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y-1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                Chunk_TL_N=Chunk_TL #Update the top left corner of the chunk
                x_TR=x_Cut-1 #Update the top right corner of the chunk
                Chunk_TR_N=grid(x_TR,y_TR)
                y_BL=y_Cut+1 #Update the bottom left corner of the chunk
                Chunk_BL_N=grid(x_BL,y_BL)
                x_BR=x_Cut-1 #Update the bottom right corner of the chunk
                y_BR=y_Cut+1
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk[0]=Chunk_TL_N #Store the updated chunk
                Chunk[1]=Chunk_TR_N
                Chunk[2]=Chunk_BL_N
                Chunk[3]=Chunk_BR_N
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                Chunk_TL_N=grid(x_TL,y_TL)
                Chunk_TR_N=Chunk_TR #Store the top right corner of the new chunk
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                y_BL=y_Cut+1
                Chunk_BL_N=grid(x_BL,y_BL)
                y_BR=y_Cut+1 #Store the bottom right corner of the new chunk
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                y_TL=y_Cut-1 #Store the top left corner of the new chunk
                Chunk_TL_N=grid(x_TL,y_TL)
                x_TR=x_Cut-1 #Store the top right corner of the new chunk
                y_TR=y_Cut-1
                Chunk_TR_N=grid(x_TR,y_TR)
                Chunk_BL_N=Chunk_BL #Store the bottom left corner of the new chunk
                x_BR=x_Cut-1 #Store the bottom right corner of the new chunk
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                y_TL=y_Cut-1
                Chunk_TL_N=grid(x_TL,y_TL)
                y_TR=y_Cut-1 #Store the top right corner of the new chunk
                Chunk_TR_N=grid(x_TR,y_TR)
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                Chunk_BL_N=grid(x_BL,y_BL)
                Chunk_BR_N=Chunk_BR #Store the bottom right corner of the new chunk
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
            if Chunk_num_F == Chunk_num: #Check is all chunk is finished
                Done=True
    Deploy() #Plot player and exit position
    if mode == 1:
        print("System: Maze 0"+mn+" loaded successfully")
        time.sleep(0.1)
    maze_solve()

def check_state(Maze,Not_Maze,Done): #Loop-erased random walk method debug function
    global temp_Maze
    global temp_Not_Maze
    global temp_Done
    temp_Maze=Maze
    temp_Not_Maze=Not_Maze
    temp_Done=Done
    
def print_state(): #Loop-erased random walk method debug function
    print("")
    print_board()
    print("")
    print("System: Printing maze state...")
    print("Maze:")
    for y in range(int((Size-1)/2)):
        print(*[temp_Maze[x][int((Size-1)/2)-y-1] for x in range(int((Size-1)/2))])
    print("Not Maze:"+ str(temp_Not_Maze))
    print("Done:", temp_Done)

def grid(x,y): #Convert Location vector to Grid format
    #Grid format: Location vector in "0519" form, x=5 y=19
    if x<10:
        temp="0"+str(x)
    else:
        temp=str(x)
    if y<10:
        temp=temp+"0"+str(y)
    else:
        temp=temp+str(y)
    return temp

def Deploy(): #Plot player and exit position
    global Size
    global board
    y=Size-1
    Plot=False
    while not(Plot): #Randomize the player position
        x=random.randint(1,(Size-1))
        if x%2 == 0 :
            x=(x%2)+(x//2)+1
            x=x*random.randint(1,2)
            if x%2 == 0 :
                x=x+1
        if not(x >= Size):
            if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the player is start at the end of the path
                Plot=True
    Board[x][y]="P" #Player starting point
    y=0
    Plot=False
    while not(Plot): #Randomize the exit position
        x=random.randint(1,(Size-1))
        if x%2 == 0 :
            x=(x%2)+(x//2)+1
            x=x*random.randint(1,2)
            if x%2 == 0 :
                x=x+1
        if not(x >= Size):
            if Board[x-1][y+1] == "X" or Board[x+1][y+1] == "X": #Making sure the exit is at the end of the path
                Plot=True
    Board[x][y]="E" #Exit point

def player_found(): #Automated relocate player position
    global Board
    global Size
    found=False #Register did the player position found
    x=0
    y=0
    try_n=0
    while found != True: #Automated relocate player position
        if Board[x][y] == "P":
            found=True
        else:
            y=y+1
            if y > (Size-1):
                x=x+1
                y=0
                if x > (Size-1):
                    if try_n != 3:
                        x=0
                        y=0
                        try_n=try_n+1
                    else:
                        print("System: ERROR")
                        print("System: Player position not found, please restart the game")
                        ans=input("System: Press Enter to exit the game ")
                        sys.exit()
    coordinate=grid(x,y)
    return coordinate #Return player coordinate in Grid fromat

def maze_solve():
    global Board
    global Size
    global Difficulty
    global rec_step
    global mode
    global cycle
    global steps
    global timer
    retry_cycle=0
    passed = False
    if mode == 1:
        print("System: Calculating recommended steps...")
    while not (passed):
        rec_step=0
        Method=1
        if Method == 1: #Depth-First Search(DFS)
            Path=[] #Store the walked path in grid format
            Junctions=[] #Store the junctions in grid format
            Junction3=[] #Store the junctions that got 3 exit in grid format
            reach=False #Register did the exit reached
            temp=player_found() #Found player location
            x=int(temp[0:2])
            y=int(temp[2:4])
            y=y-1
            rec_step=rec_step+1
            Board[x][y]="0"
            Path.append(grid(x,y))
            while not(reach): #Check is the exit reached
                exit_way=[] #Direction of walkable path
                exit_num=0 #Number of walkable path
                direction=None #Direction of walk
                if Board[x][y-1] == "E": #Check is the bottom box the exit
                    rec_step=rec_step+1
                    reach=True
                elif Board[x][y-1] == " ": #Check is the bottom box the path
                    exit_num=exit_num+1
                    exit_way.append("down")
                if Board[x-1][y] == " ": #Check is the left box the path
                    exit_num=exit_num+1
                    exit_way.append("left")
                if Board[x][y+1] == " ": #Check is the top box the path
                    exit_num=exit_num+1
                    exit_way.append("up")
                if Board[x+1][y] == " ": #Check is the right box the path
                    exit_num=exit_num+1
                    exit_way.append("right")
                if exit_num == 1: #One-way path
                    direction=0
                elif exit_num == 2: #2-way junction
                    Junctions.append(grid(x,y))
                    direction=random.randint(0,1) #Random choose a way to walk
                elif exit_num == 3: #3-way junction
                    Junctions.append(grid(x,y))
                    Junction3.append(grid(x,y))
                    direction=random.randint(0,2) #Random choose a way to walk
                if reach != True:
                    if direction != None: #Move
                        if exit_way[direction] == "up": #Walk up
                            y=y+1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "down": #Walk down
                            y=y-1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "left": #Walk left
                            x=x-1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "right": #Walk right
                            x=x+1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                    elif (direction == None) and (exit_num == 0): #Dead end
                        back=False
                        while not(back): #Check did it arrive at the previous junction
                            Board[x][y]="/"
                            Path.pop()
                            rec_step=rec_step-1
                            temp=Path[len(Path)-1] #Move back
                            x=int(temp[0:2])
                            y=int(temp[2:4])
                            if len(Junction3) != 0: #Check is there any 3-way junction
                                if temp == Junction3[len(Junction3)-1]: #Check is it at the 3-way junction
                                    Junction3.pop()
                                    back=True
                            if back != True:
                                if temp == Junctions[len(Junctions)-1]: #Check is it at the junction
                                    Junctions.pop()
                                    back=True
            x=1
            y=0
            while (x != Size-2) or (y != Size-2): #Cleaning up the board
                if y+1 == Size-1: #Check did it reach the top
                    y=1
                    x=x+1
                else:
                    y=y+1
                if Board[x][y] != "X": #Replace the path
                    Board[x][y]=" "
        elif Method == 2: #Breadth-First Search(BFS)
            None
        elif Method == 3: #A* Search
            None
        min_step=Size*Size*0.1 #Minimum steps to solve the maze depend on size
        if rec_step <= min_step: #Make sure the recommended steps is not too low
            for k in range(Size): #Redraw the top and bottom edge
                Board[k][0] = "X"
                Board[k][Size-1] = "X"
            Deploy()
            retry_cycle=retry_cycle+1
            if retry_cycle == 3: #Maximum number of retry
                build_maze() #Restart the maze generation if it exceed the maximum number of retry
        else:
            passed=True
    rec_step=rec_step+10 #Add some buffer to the recommended steps
    quick_test() #Test
    cycle=cycle+1
    if cycle == 1:
        steps=0
        if mode == 1:
            print("System: Recommend steps for this maze:", rec_step)
            time.sleep(0.1)
            if Difficulty == 5:
                ans=input("System: Press Enter to start ")
                timer.start()
            game()
        elif mode == 2:
            draw_maze()
        else:
            print("System: ERROR")
            print("System: User interface not recognised, please restart the game")
            ans=input("System: Press Enter to exit the game ")
            sys.exit()

def quick_test(): #Test
    global Board
    temp=player_found() #Found player location
    x=int(temp[0:2])
    y=int(temp[2:4])
    y=y-1
    Board[x][y]="E"

def Timer(): #10 minutes timer (Sub-thread)
    global Time_up
    global Minutes
    global Second
    global mode
    global screen
    global Timer_stop
    Timer_stop=False
    Time_up=False
    Minutes=0
    Second=0
    if mode == 1:
        time.sleep(1)
        tick()
    elif mode == 2:
        screen.ontimer(tick,1000)

def tick():
    global Time_up
    global Minutes
    global Second
    global Difficulty
    global mode
    global screen
    global Timer_stop
    Second=Second+1
    if Second == 60:
        Minutes=Minutes+1
        Second=0
    if Difficulty == 5:
        if (Minutes == 10) and (Second == 0):
            Timer_stop=True
            Time_up=True
            if mode == 1:
                print("\nSystem: Times up")
            end(False)
    if mode == 1:
        time.sleep(1)
        tick()
    elif mode == 2:
        timer_upd()
        screen.ontimer(tick, 1000) #Call tick function every second

def Menu_CLI(): #CLI menu
    global Size
    global Board
    global Type_error
    global Difficulty
    global mode
    print("System: This game is for single players")
    time.sleep(1)
    print("System: The icon 'X' represent the wall, and icon ' ' represent the path")
    time .sleep(1)
    print("System: Icon 'P' is the player, and icon 'E' is the exit")
    time.sleep(1)
    print("System: You can move in four directions")
    time.sleep(1)
    print("System: Up(W), Down(S), Left(A), Right(D)")
    time.sleep(1)
    print("System: Single character is entered everytime")
    time.sleep(1)
    print("System: Press Enter to execute the action")
    time.sleep(1)
    print("System: Every steps you take will be recorded")
    time.sleep(1)
    print("System: Your goal is to exit the maze with fewest steps")
    time.sleep(1)
    print("System: In Hardcore Mode your steps was limmited, think carefully before moving")
    time.sleep(1)
    print("System: You are not allow to use more steps than the system recommended in Hardcore Mode")
    time.sleep(1)
    ans=input("System: Press Enter to start the game or enter /GUI to swap to GUI manu")
    if ans.lower() == "/gui":
        mode=2
        menu_setup() #Swap to graphical user interface
    else:
        Type_error=False
        while not Type_error:
            try:
                ans=int(input("System: Please enter difficulty: 1(21*21 Board), 2(31*31 Board), 3(41*41 Board), 4(51*51 Board), 5(Hardcore Mode) "))
                if ans <=0 or ans > 5:
                    print("System: Out of bounds")
                else:
                    Type_error=True
                    Difficulty=ans
            except:
                print("System: Formet error")
        Type_error=False
        if Difficulty == 5:
            ans=4
        Size=(ans+1)*10+1 #Calculate board size
        print("System: Good luck!")
        time.sleep(0.5)
        build_maze()

def menu_setup(): #GUI screen setup
    global t
    global screen
    global pen
    try:
        screen.clear()
    except:
        screen=t.Screen()
    screen.title("Maze Game")
    screen.bgcolor("White")
    screen.setup(width=550, height=650)
    screen.tracer(0)
    try:
        pen.bye()
    except:
        pen=t.Turtle()
    pen.hideturtle()
    pen.penup()
    screen.update()
    Menu_GUI()

def Menu_GUI(): #GUI main menu
    global t
    global screen
    global page
    global pen
    global Instruction_bt
    global Start_bt
    global Setting_bt
    global Exit_bt
    global CLI_bt
    page=0 #Menu id
    pen.penup()
    pen.clear() #Clear the board
    pen.goto(0,200)
    pen.write("Maze Game", align="center", font=("Arial", 50, "bold")) #Game title
    style="Arial", 25, "bold"
    Instruction_bt=Button(-100,125,200,50,"Instruction",style)
    Instruction_bt.draw() #Draw instruction button
    Start_bt=Button(-100,25,200,50,"Start",style)
    Start_bt.draw() #Draw start button
    Setting_bt=Button(-100,-75,200,50,"Setting",style)
    Setting_bt.draw() #Draw setting button
    Exit_bt=Button(-250,-250,100,50,"Exit",style)
    Exit_bt.draw() #Draw exit button
    CLI_bt=Button(150,-250,100,50,"CLI",style)
    CLI_bt.draw() #Draw CLI button
    screen.update()
    screen.listen()
    screen.onclick(button_click)
    screen.mainloop() #Keep the window open

def button_click(x,y): #Mouse clicked
    global screen
    global page
    global Difficulty
    global mode
    global Size
    global Instruction_bt #Instruction button
    global Start_bt #Start button
    global Setting_bt #Setting button
    global Exit_bt #Exit button
    global Return_bt #Return button
    global CLI_bt #CLI button
    global Difficulty_btL #Difficulty left arrow button
    global Difficulty_btR #Difficulty right arrow button
    global Restart_bt #Restart button
    global cycle
    screen.update()
    if page == 0: #From menu
        if Instruction_bt.get_x_min() < x < Instruction_bt.get_x_max() and Instruction_bt.get_y_min() < y < Instruction_bt.get_y_max(): #Instruction button pressed
            instruction()
        elif Start_bt.get_x_min() < x < Start_bt.get_x_max() and Start_bt.get_y_min() < y < Start_bt.get_y_max(): #Start button pressed
            Difficulty=1
            game_setting()
        elif Setting_bt.get_x_min() < x < Setting_bt.get_x_max() and Setting_bt.get_y_min() < y < Setting_bt.get_y_max(): #Setting button pressed
            setting()
        elif Exit_bt.get_x_min() < x < Exit_bt.get_x_max() and Exit_bt.get_y_min() < y < Exit_bt.get_y_max(): #Exit button pressed
            screen.bye()
            sys.exit()
        elif CLI_bt.get_x_min() < x < CLI_bt.get_x_max() and CLI_bt.get_y_min() < y < CLI_bt.get_y_max(): #CLI button pressed
            screen.bye()
            mode=1
            Menu_CLI() #Swap to command line interface
    elif page == 1: #From instruction
        if Return_bt.get_x_min() < x < Return_bt.get_x_max() and Return_bt.get_y_min() < y < Return_bt.get_y_max(): #Return button pressed
            Menu_GUI()
    elif page == 2: #From game_setting
        if Return_bt.get_x_min() < x < Return_bt.get_x_max() and Return_bt.get_y_min() < y < Return_bt.get_y_max(): #Return button pressed
            Menu_GUI()
        elif Difficulty_btL.get_x_min() < x < Difficulty_btL.get_x_max() and Difficulty_btL.get_y_min() < y < Difficulty_btL.get_y_max(): #Difficulty left arrow button pressed
            if Difficulty > 1: #Decrease difficulty
                Difficulty=Difficulty-1
                game_setting()
        elif Difficulty_btR.get_x_min() < x < Difficulty_btR.get_x_max() and Difficulty_btR.get_y_min() < y < Difficulty_btR.get_y_max(): #Difficulty right arrow button pressed
            if Difficulty < 5: #Increase difficulty
                Difficulty=Difficulty+1
                game_setting()
        elif Start_bt.get_x_min() < x < Start_bt.get_x_max() and Start_bt.get_y_min() < y < Start_bt.get_y_max(): #Start button pressed
            game_setup()
    elif page == 3: #From setting
        if Return_bt.get_x_min() < x < Return_bt.get_x_max() and Return_bt.get_y_min() < y < Return_bt.get_y_max(): #Return button pressed
            Menu_GUI()
    elif page == 4: #From in-game menu
        None
    elif page == 5: #From end menu
        if Exit_bt.get_x_min() < x < Exit_bt.get_x_max() and Exit_bt.get_y_min() < y < Exit_bt.get_y_max(): #Exit button pressed
            screen.bye()
            sys.exit()
        elif Restart_bt.get_x_min() < x < Restart_bt.get_x_max() and Restart_bt.get_y_min() < y < Restart_bt.get_y_max(): #Restart button pressed
            screen.reset()
            cycle=0
            main()

def instruction(): #GUI instruction
    global screen
    global page
    global pen
    global Return_bt
    page=1
    pen.clear() #Clear screen
    style="Arial", 15, "bold"
    y=275 #Fist row
    pen.goto(0,y)
    pen.write("- This game is for single players -", align="center", font=(style))
    y=y-50 #Second row
    pen.goto(0,y)
    pen.write("- The green curser is the player -", align="center", font=(style))
    y=y-50 #Third row
    pen.goto(0,y)
    pen.write("- And red box is the exit -", align="center", font=(style))
    y=y-50 #Fourth row
    pen.goto(0,y)
    pen.write("- You can move in four directions -", align="center", font=(style))
    y=y-50 #Fifth row
    pen.goto(0,y)
    pen.write("- Up(W), Down(S), Left(A), Right(D) -", align="center", font=(style))
    y=y-50 #Sixth row
    pen.goto(0,y)
    pen.write("- Every steps you take will be recorded -", align="center", font=(style))
    y=y-50 #Seventh row
    pen.goto(0,y)
    pen.write("- Your goal is to exit the maze with fewest steps -", align="center", font=(style))
    y=y-50 #Eighth row
    pen.goto(0,y)
    pen.write("- In Hardcore Mode your steps was limmited -", align="center", font=(style))
    y=y-50 #Nineth row
    pen.goto(0,y)
    pen.write("- Think carefully before moving -", align="center", font=(style))
    y=y-50 #Tenth row
    pen.goto(0,y)
    pen.write("- You are not allow to use more steps than", align="center", font=(style))
    y=y-50 #Eleventh row
    pen.goto(0,y)
    pen.write("the system recommended in Hardcore Mode -", align="center", font=(style))
    style="Arial", 25, "bold"
    Return_bt=Button(-250,-250,125,50,"Return",style)
    Return_bt.draw() #Draw return button
    screen.update()
    screen.listen()
    screen.onclick(button_click)

def game_setting(): #GUI game setting
    global screen
    global page
    global pen
    global Difficulty
    global Difficulty_btL
    global Difficulty_btR
    global Start_bt
    global Return_bt
    page=2
    pen.clear() #Clear screen
    x=-170 #Difficulty text position
    y=25
    style="Arial", 25, "bold"
    pen.goto(x,y-42.5)
    pen.write("Difficulty:", align="center", font=(style))
    x=x+85 #Difficulty text to difficulty left arrow button TL position
    Difficulty_btL=Button_L(x,y,25,50)
    Difficulty_btL.draw()
    x=x+30 #Difficulty left arrow button TL to difficulty display TL position
    pen.penup() #Finish drawing left arrow button
    if Difficulty == 1: #Set difficulty
        text="1(21*21 Board)"
    elif Difficulty == 2:
        text="2(31*31 Board)"
    elif Difficulty == 3:
        text="3(41*41 Board)"
    elif Difficulty == 4:
        text="4(51*51 Board)"
    elif Difficulty == 5:
        text="5(Hardcore Mode)"
    Difficulty_dp=Button(x,y,285,50,text,style)
    Difficulty_dp.draw() #Draw current difficulty display
    pen.penup() #Finish drawing current difficulty display
    x=x+290 #Difficulty display to difficulty right arrow button TL position
    Difficulty_btR=Button_R(x,y,25,50)
    Difficulty_btR.draw()
    Start_bt=Button(-50,-100,100,50,"Start",style)
    Start_bt.draw() #Draw start button
    Return_bt=Button(-250,-250,125,50,"Return",style)
    Return_bt.draw() #Draw return button
    screen.update()
    screen.listen()
    screen.onclick(button_click)

def setting(): #GUI setting
    global screen
    global page
    global pen
    global Return_bt
    page=3
    pen.clear() #Clear screen
    pen.goto(0,0)
    style="Arial", 25, "bold"
    Return_bt=Button(-250,-250,125,50,"Return",style)
    Return_bt.draw() #Draw return button
    screen.update()
    screen.listen()
    screen.onclick(button_click)

def game_setup(): #Game GUI setup
    global t
    global screen
    global Size
    global Ratio
    global page
    global player
    global system
    global step_pn
    global timer_pn
    global menu_width
    page=4
    screen.clear() #Clear screen
    temp=Difficulty
    if Difficulty == 5:
        temp=4
    Size=(temp+1)*10+1 #Calculate board size
    Ratio=min(screen.cv.winfo_screenwidth()/Size, screen.cv.winfo_screenheight()/Size)* 0.85 #Set screen size using monitor resolution
    menu_width=Size*Ratio/4 #In game menu width
    screen.setup(width=Size*Ratio+0.25*Ratio+menu_width, height=Size*Ratio+0.25*Ratio)
    screen.tracer(0)
    screen.update()
    pen.clear() #GUI drawing
    pen.shapesize((Ratio/20), (Ratio/20))
    pen.color("black")
    pen.hideturtle()
    pen.penup()
    pen.goto((Ratio/4),0) #Center
    try:
        player.bye()
    except:
        player=t.Turtle() #Player character
    player.shapesize((Ratio/20), (Ratio/20))
    player.penup()
    player.color("green")
    player.goto((Ratio/4),0)
    player.hideturtle()
    try:
        system.bye()
    except:
        system=t.Turtle() #Output massage
    system.shapesize(1,1)
    system.penup()
    system.color("red")
    system.goto(0,0)
    system.hideturtle()
    try:
        step_pn.bye()
    except:
        step_pn=t.Turtle() #Steps count
    step_pn.shapesize(1,1)
    step_pn.penup()
    step_pn.color("black")
    step_pn.hideturtle()
    try:
        timer_pn.bye()
    except:
        timer_pn=t.Turtle() #Timer count
    timer_pn.shapesize(1,1)
    timer_pn.penup()
    timer_pn.color("black")
    timer_pn.hideturtle()
    screen.update()
    build_maze()

def draw_maze():
    global Board
    global pen
    global screen
    global Size
    global Ratio
    global player
    global menu_width
    i=0
    j=Size-1 #Board top left corner
    #Maze bottom-left corner setted
    maze_x0=-screen.window_width()/2-Ratio/1.25+menu_width
    maze_y0=-screen.window_height()/2+Ratio/1.25
    while (i < Size) and (j != -1):
        #Convert Board[i][j] location vecter to Screen x,y
        x=maze_x0+i*Ratio+Ratio/2
        y=maze_y0+j*Ratio+Ratio/2
        if Board[i][j] == "X": #Draw wall
            wall_block(x,y,"black")
        elif Board[i][j] == "E": #Draw exit
            wall_block(x,y,"red")
        elif Board[i][j] == "P": #Draw player start
            wall_block(x,y,"blue")
            player.goto(x+Ratio/2,y-Ratio/2)
            player.setheading(270)
        i=i+1
        if i == Size:
            i=0
            j=j-1
    player.showturtle()
    screen.update()
    draw_menu()

def draw_menu():
    global step_pn
    global timer_pn
    global pen
    global screen
    global Ratio
    global menu_width
    global item_height
    global mn
    global rec_step
    global page
    menu_x0=-screen.window_width()/2
    items=5 #Maze ID, Recommend steps, Steps, Timer, Return button
    margin=screen.window_height()*0.05
    menu_height=screen.window_height()-margin #Menu available height
    bounds=menu_width*0.05
    menu_width=menu_width*0.9 #Menu available width
    item_height=menu_height/6 #Items height
    spacing=menu_height/6/4 #Distance between Items
    style="Arial", int(item_height*0.1), "bold" #Set text format
    menu_center=menu_x0+menu_width/2+bounds #Menu horizontal center x coordinate
    y=screen.window_height()/2-margin/2-item_height/2 #First item y coordinate
    pen.goto(menu_center,y)
    text="Maze 0"+mn
    pen.write(text, align="center", font=(style))
    y=y-item_height/2-spacing-item_height/2 #Second item y coordinate
    pen.goto(menu_center,y)
    text="Recommend steps: "+ str(rec_step)
    pen.write(text, align="center", font=(style))
    y=y-item_height/2-spacing-item_height/2 #Third item y coordinate
    step_pn.goto(menu_center,y)
    text="Steps: 0"
    step_pn.write(text, align="center", font=(style))
    y=y-item_height/2-spacing-item_height/2 #Fourth item y coordinate
    timer_pn.goto(menu_center,y)
    text="Timer: 00:00"
    timer_pn.write(text, align="center", font=(style))
    screen.update()
    ready()

def ready(): #Ready to start the game
    global screen
    global system
    global Ratio
    system.clear()
    system.write("Press Enter to start", align="center", font=("Arial", int(Ratio), "bold"))
    screen.bgcolor("black")
    screen.onkeypress(Start,"Return")
    screen.listen()
    screen.update()
    screen.mainloop() #Keep the window open

def Start(): #Start the game
    global screen
    global system
    system.clear()
    screen.bgcolor("white")
    screen.onkeypress(None,"Return")
    screen.onkeypress(move_up,"w")
    screen.onkeypress(move_down,"s")
    screen.onkeypress(move_left,"a")
    screen.onkeypress(move_right,"d")
    screen.listen()
    Timer() #Start timer
    screen.update()


def steps_upd(): #Update steps count
    global step_pn
    global steps
    global screen
    global item_height
    step_pn.clear()
    text="Steps: "+str(steps)
    step_pn.write(text, align="center", font=("Arial", int(item_height*0.1), "bold"))
    screen.update()

def timer_upd(): #Update timer count
    global timer_pn
    global Minutes
    global Second
    global Screen
    global item_height
    timer_pn.clear()
    temp=grid(Minutes,Second)
    text="Timer: "+temp[0:2]+":"+temp[2:4]
    timer_pn.write(text, align="center", font=("Arial", int(item_height*0.1), "bold"))
    screen.update()

def wall_block(x,y,color):
    global pen
    global screen
    global Ratio
    pen.color(color)
    pen.goto(x,y) #Top left
    pen.pendown()
    pen.begin_fill()
    pen.goto(x+Ratio,y) #Top right
    pen.goto(x+Ratio,y-Ratio)#Bottom right
    pen.goto(x,y-Ratio)#Bottom left
    pen.goto(x,y) #Top left
    pen.end_fill()
    pen.penup()
    screen.update()

def Invalid_move(direction): #Error massage output
    global system
    global screen
    style="Arial", 25, "bold"
    system.goto(0,25)
    system.write("Invalid Move", align="center", font=(style))
    system.goto(0,-25)
    text="You Cannot Move "+direction
    system.write(text, align="center", font=(style))
    screen.ontimer(Sys_wait_2_second, 2000) #Execute after 2 second
    screen.update()

def Sys_wait_2_second(): #System massage clear after 2 second
    global system
    system.clear()

def move_up():
    global Board
    global Player
    global Size
    global Screen
    global Ratio
    global steps
    temp=player_found() #Found player location
    x=int(temp[0:2])
    y=int(temp[2:4])
    player.setheading(90) #Curser turn toward up
    if y < (Size-1) and Board[x][y+1] != "X":
        Board[x][y]=" "
        y=y+1
        steps=steps+1
        steps_upd()
        if Board[x][y] == "E":
            Board[x][y]="P"
            end(True)
        else:
            Board[x][y]="P" #Change player postion in board
            x=player.xcor()
            y=player.ycor()
            y=y+Ratio
            player.goto(x,y) #Player curser move up
    else:
        Invalid_move("Up")
    screen.update()

def move_down():
    global Board
    global Player
    global Size
    global Screen
    global Ratio
    global steps
    temp=player_found() #Found player location
    x=int(temp[0:2])
    y=int(temp[2:4])
    player.setheading(270) #Curser turn toward down
    if y > 0 and Board[x][y-1] != "X":
        Board[x][y]=" "
        y=y-1
        steps=steps+1
        steps_upd()
        if Board[x][y] == "E":
            Board[x][y]="P"
            end(True)
        else:
            Board[x][y]="P" #Change player postion in board
            x=player.xcor()
            y=player.ycor()
            y=y-Ratio
            player.goto(x,y) #Player curser move down
    else:
        Invalid_move("Down")
    screen.update()

def move_left():
    global Board
    global Player
    global Size
    global Screen
    global Ratio
    global steps
    temp=player_found() #Found player location
    x=int(temp[0:2])
    y=int(temp[2:4])
    player.setheading(180) #Curser turn toward left
    if x > 0 and Board[x-1][y] != "X":
        Board[x][y]=" "
        x=x-1
        steps=steps+1
        steps_upd()
        if Board[x][y] == "E":
            Board[x][y]="P"
            end(True)
        else:
            Board[x][y]="P" #Change player postion in board
            x=player.xcor()
            y=player.ycor()
            x=x-Ratio
            player.goto(x,y) #Player curser move left
    else:
        Invalid_move("Left")
    screen.update()

def move_right():
    global Board
    global Player
    global Size
    global Screen
    global Ratio
    global steps
    temp=player_found() #Found player location
    x=int(temp[0:2])
    y=int(temp[2:4])
    player.setheading(0) #Curser turn toward right
    if x < (Size-1) and Board[x+1][y] != "X":
        Board[x][y]=" "
        x=x+1
        steps=steps+1
        steps_upd()
        if Board[x][y] == "E":
            Board[x][y]="P"
            end(True)
        else:
            Board[x][y]="P" #Change player postion in board
            x=player.xcor()
            y=player.ycor()
            x=x+Ratio
            player.goto(x,y) #Player curser move right
    else:
        Invalid_move("Right")
    screen.update()

def main(): #Start point
    global timer
    global mode
    global cycle
    timer=threading.Thread(target=Timer) #Setup sub-thread
    mode=2
    cycle=0 #Threshold
    if mode == 1: #CLI
        Menu_CLI()
    elif mode == 2: #GUI
        menu_setup()
    else:
        print("System: ERROR")
        print("System: User interface initialize fail, please restart the game")
        ans=input("System: Press Enter to exit the game ")
        sys.exit()

class Button:
    def __init__(self, x, y, width, height, text, style):
        self.x=x #Top left x coordinate
        self.y=y #Top left y coordinate
        self.width=width
        self.height=height
        self.text=text
        self.style=style
    
    def get_x_min(self): #Return the x value bottom bound
        return self.x
    
    def get_x_max(self): #Return the x value upper bound
        return self.x+self.width
    
    def get_y_min(self): #Return the y value bottom bound
        return self.y-self.height
    
    def get_y_max(self): #Return the y value upper bound
        return self.y

    def draw(self): #Draw button
        global pen
        global screen
        pen.goto(self.x,self.y) #TL of the button
        pen.pendown() #Start drawing the button
        pen.goto(self.x+self.width,self.y) #TR of the button
        pen.goto(self.x+self.width,self.y-self.height) #BR of the button
        pen.goto(self.x,self.y-self.height) #BL of the button
        pen.goto(self.x,self.y) #TL of the button
        pen.penup() #Finish drawing the button
        pen.goto(self.x+(self.width/2),self.y-self.height+5)
        pen.write(self.text, align="center", font=self.style)#Write text
        screen.update()

class Button_L: #Left arrow button
    def __init__(self, x, y, width, height):
        self.x=x #Top left x coordinate
        self.y=y #Top left y coordinate
        self.width=width
        self.height=height

    def get_x_min(self): #Return the x value bottom bound
        return self.x
    
    def get_x_max(self): #Return the x value upper bound
        return self.x+self.width
    
    def get_y_min(self): #Return the y value bottom bound
        return self.y-self.height
    
    def get_y_max(self): #Return the y value upper bound
        return self.y

    def draw(self): #Draw button
        global pen
        global screen
        pen.goto(self.x,self.y) #TL of the button
        pen.pendown() #Start drawing the button
        pen.goto(self.x+self.width,self.y) #TR of the button
        pen.goto(self.x+self.width,self.y-self.height) #BR of the button
        pen.goto(self.x,self.y-self.height) #BL of the button
        pen.goto(self.x,self.y) #TL of the button
        pen.penup()
        pen.goto(self.x+5,self.y-self.height/2) #Arrow left point
        pen.pendown() #Start drawing arrow
        pen.begin_fill()
        pen.fillcolor("black")
        pen.goto(self.x+self.width-5,self.y-5) #Arrow top right point
        pen.goto(self.x+self.width-5,self.y-self.height+5) #Arrow bottom right point
        pen.goto(self.x+5,self.y-self.height/2) #Arrow left point
        pen.end_fill()
        pen.penup() #Finish drawing the button
        screen.update()

class Button_R: #Right arrow button
    def __init__(self, x, y, width, height):
        self.x=x #Top left x coordinate
        self.y=y #Top left y coordinate
        self.width=width
        self.height=height

    def get_x_min(self): #Return the x value bottom bound
        return self.x
    
    def get_x_max(self): #Return the x value upper bound
        return self.x+self.width
    
    def get_y_min(self): #Return the y value bottom bound
        return self.y-self.height
    
    def get_y_max(self): #Return the y value upper bound
        return self.y

    def draw(self): #Draw button
        global pen
        global screen
        pen.goto(self.x,self.y) #TL of the button
        pen.pendown() #Start drawing the button
        pen.goto(self.x+self.width,self.y) #TR of the button
        pen.goto(self.x+self.width,self.y-self.height) #BR of the button
        pen.goto(self.x,self.y-self.height) #BL of the button
        pen.goto(self.x,self.y) #TL of the button
        pen.penup()
        pen.goto(self.x+5,self.y-5) #Arrow top left point
        pen.pendown() #Start drawing arrow
        pen.begin_fill()
        pen.fillcolor("black")
        pen.goto(self.x+self.width-5,self.y-self.height/2) #Arrow right point
        pen.goto(self.x+5,self.y-self.height+5) #Arrow bottom leftight point
        pen.goto(self.x+5,self.y-5) #Arrow top left point
        pen.end_fill()
        pen.penup() #Finish drawing the button
        screen.update()

import time
import random
import sys
import threading
import turtle as t
import os
main()
