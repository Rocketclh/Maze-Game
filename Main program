def game(): #Cmd game control
    global steps
    global Board
    global Size
    global Type_error
    global Difficulty
    global rec_step
    if Type_error:
        Type_error=False
    else:
        print_board()
    found=False
    x=0
    y=0
    while found != True: #Automated relocate player position
        if Board[x][y] == "P":
            found=True
        else:
            y=y+1
            if y > (Size-1):
                x=x+1
                y=0
                if x > (Size-1):
                    print("System: ERROR")
                    print("System: Player position not found, please restart the game")
                    ans=input("System: Press Enter to exit the game ")
                    sys.exit()
    if Difficulty == 5:
        if steps == rec_step:
            end(False)
    ans=input("System: Please enter the direction you want to move ")
    ans=ans.lower()
    if ans == "w": #Move up
        if y < (Size-1) and Board[x][y+1] != "X":
            Board[x][y]=" "
            y=y+1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move up")
            Type_error=True
            time.sleep(0.5)
    elif ans == "s": #Move down
        if y > 0 and Board[x][y-1] != "X":
            Board[x][y]=" "
            y=y-1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move down")
            Type_error=True
            time.sleep(0.5)
    elif ans == "a": #Move left
        if x > 0 and Board[x-1][y] != "X":
            Board[x][y]=" "
            x=x-1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move left")
            Type_error=True
            time.sleep(0.5)
    elif ans == "d": #Move right
        if x < (Size-1) and Board[x+1][y] != "X":
            Board[x][y]=" "
            x=x+1
            steps=steps+1
            if Board[x][y] == "E":
                end(True)
            else:
                Board[x][y]="P"
        else:
            print("System: Invalid move!")
            print("System: You cannot move right")
            Type_error=True
            time.sleep(0.5)
    elif len(ans) != 1:
        print("System: Out of Range!")
        print("System: Please enter single character")
        Type_error=True
        time.sleep(0.5)
    else:
        print("System: Invalid input!")
        print("System: Please enter 'W', 'A', 'S', or 'D'")
        Type_error=True
        time.sleep(0.5)
    game()

def end(win): #Cmd win output
    global steps
    global rec_step
    if win:
        print("System: Congratulations!")
        print("System: You have exited the maze!")
        print("System: Total steps taken:", steps)
        print("System: Maze recommended steps:", rec_step)
    else:
        print("System: Game Over")
        print("System: You have used all of the steps")
        print("System: Total steps taken:", steps)
        print("System: Maze recommended steps:", rec_step)
    time.sleep(0.5)
    ans=input("System: Press Enter to exit the game or type '/restart' to restart the game ")
    if ans.lower() == "/restart":
        for i in range(5):
            print("")
        main()
    else:
        sys.exit()

def print_board(): #Cmd board
    global Board
    global Size
    print("")
    for y in range(Size): #0,0 at bottem left corner
        h=Size-y-1 #Height of the board
        if h<10:
            temp="0"+str(h)
        else:
            temp=str(h)
        print(temp, *[Board[x][h] for x in range(Size)])
    print("")

def build_maze():
    global Board
    global Size
    mn=str(random.randint(1,999)) #Random generate maze ID
    if mode == 1:
        print("System: Loading Maze 0"+mn+"...")
    i=2 #Maze generation method using
    if i == 1: #Loop-erased random walk method
        #Maze format: node only
        #Board format: node and line(path)
        #Grid format: Location vector in "0519" form, x=5 y=19
        Board=[["X"] * Size for z in range(Size)]
        x=1
        y=1
        Board[x][y]=" "
        Maze=[["F"] * int((Size-1)/2) for n in range(int((Size-1)/2))] #Store the cell that are part of the maze, grid is stored in node form, lines are not included
        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
        y=int((x+1)/2-1)
        Maze[x][y]="T"
        Done=False #Register maze is fully finished
        while not(Done): #Check is all node included in the maze
            Done=True
            Not_Maze=[] #The cell that are not part of the maze, 1D array, in maze format
            for h in range(0,len(Maze)): #x-axis
                for v in range(0,len(Maze)): #y-axis
                    if Maze[h][v] == "F": #Check is it part of maze
                        Done=False
                        Not_Maze.append(grid(h,v)) #Storing the Location vector in Grid format
            if not Done:
                temp=Not_Maze[random.randint(0,len(Not_Maze)-1)] #In Maze format
                x=int(temp[0:2])
                y=int(temp[2:4])
                x=2*x+1 #Converting location vector from Maze format to Board format
                y=2*y+1
                Path=[temp] #Stored walked path, in Board format
                while Maze[int((x+1)/2-1)][int((y+1)/2-1)] != "T":
                    retry=False
                    Direction=random.randint(1,4) #1:Up 2:Down 3:Left 4:Right
                    Steps=random.randint(1,2)*2
                    if Direction == 1: #Move up
                        if y+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                y=y+1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 2: #Move down
                        if y-Steps <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                y=y-1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 3: #Move left
                        if (x-Steps) <= 0:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x-1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                    elif Direction == 4: #Move right
                        if x+Steps > Size-1:
                            retry=True
                        else:
                            for t in range(Steps):
                                x=x+1
                                found=False
                                for c in range(1,len(Path)):
                                    if Path[c] == grid(x,y):
                                        found=True
                                if found:
                                    Path = Path[:(c-1)] #Remove the path cycle
                                else:
                                    Path.append(grid(x,y)) #Storing the Location vector in Grid format
                for n in range(0, len(Path)-1): #Register paths into maze
                    temp=Path[n] #Load grid into temp, in Board format
                    x=int(temp[0:2])
                    y=int(temp[2:4])
                    Board[x][y]=" "
                    if n%2 == 0 :
                        x=int((x+1)/2-1) #Converting location vector from Board format to Maze format
                        y=int((y+1)/2-1)
                        Maze[x][y]="T"
                check_state(Maze,Not_Maze,Done)
                for k in range(Size): #Redraw the edge
                    Board[0][k] = "X"
                    Board[Size-1][k] = "X"
                    Board[k][0] = "X"
                    Board[k][Size-1] = "X"
    elif i == 2: #Recursive division method
        #Grid format: Location vector in "0519" form, x=5 y=19
        Board=[[" "] * Size for z in range(Size)]
        for k in range(Size): #Draw the edge
            Board[0][k] = "X"
            Board[Size-1][k] = "X"
            Board[k][0] = "X"
            Board[k][Size-1] = "X"
        Chunk=[] #Store the chunks, each chunck stored in oreder of Top left corner, Top right corner, Bottom left corner, Bottom right corner in Grid format
        Chunk_num=0 #Number of chunks
        Chunk_num_F=0 #Number of chunks that are fully finished
        for n in range(0,4):
            if n == 0: #Top left corner of the chunk
                x=1
                y=Size-2
            elif n == 1: #Top right corner of the chunk
                x=Size-2
                y=Size-2
            elif n == 2: #Bottom left corner of the chunk
                x=1
                y=1
            elif n == 3: #Bottom right corner of the chunk
                x=Size-2
                y=1
            Chunk.append(grid(x,y)) #Storing the Location vector in Grid format
        Chunk_num=Chunk_num+1
        Done = False #Register maze is fully finished
        while not(Done): #Check is the maze finished
            Chunk_TL=Chunk[0] #Top left corner of the chunk
            Chunk_TR=Chunk[1] #Top right corner of the chunk
            Chunk_BL=Chunk[2] #Bottom left corner of the chunk
            Chunk_BR=Chunk[3] #Bottom right corner of the chunk
            x_TL=int(Chunk_TL[0:2]) #Converting Grid format to location vector (x), path
            y_TL=int(Chunk_TL[2:4]) #Converting Grid format to location vector (y), path
            x_TR=int(Chunk_TR[0:2])
            y_TR=int(Chunk_TR[2:4])
            x_BL=int(Chunk_BL[0:2])
            y_BL=int(Chunk_BL[2:4])
            x_BR=int(Chunk_BR[0:2])
            y_BR=int(Chunk_BR[2:4])
            if (x_TL == x_TR) or (y_TL == y_BL): #Check is the chunk is too small
                Chunk_num_F=Chunk_num_F+1 #Update the number of chunks that are fully finished
                for n in range (0,4):
                    Chunk.pop(0) #Remove the completed chunk
            else:
                x_Cut=random.randint(x_TL,x_TR) #Randomize the cut point on x-axis
                if x_Cut%2 != 0 : #Check is the cut point is path
                    if x_Cut == x_TR:
                        x_Cut=x_Cut-1 #Making sure the cut point is even(wall) and within the chunk
                    else:
                        x_Cut=x_Cut+1 #Making sure the cut point is even(wall)
                x=x_Cut
                for y in range(y_BL,y_TL+1):
                    Board[x][y]="X" #Cut the chunk vertically
                y_Cut=random.randint(y_BL,y_TL) #Randomize the cut point on y-axis
                if y_Cut%2 != 0 : #Check is the cut point is path
                    if y_Cut == y_TL:
                        y_Cut=y_Cut-1 #Making sure the cut point is even(wall) and within the chunk
                    else:
                        y_Cut=y_Cut+1 #Making sure the cut point is even(wall)
                y=y_Cut
                for x in range(x_TL,x_TR+1):
                    Board[x][y]="X" #Cut the chunk horizontally
                Third_Hole=random.randint(0,1) #Randomize which axis will have two holes
                if Third_Hole == 0: #X-axis has two holes, Y-axis has one holes
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_TL,x_Cut) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x-1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_Cut,x_TR) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x+1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x-1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_BL,y_TL) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y-1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                elif Third_Hole == 1: #X-axis has one holes, Y-axis has two holes
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        x=random.randint(x_TL,x_TR) #Randomlize the hole point, even number is wall, odd number is path
                        if x%2 == 0 : #Check is the hole point is wall
                            if x == x_Cut:
                                x=x-1 #Making sure the hole point is path and within the chunk
                            else:
                                x=x+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_BL,y_Cut) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y-1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y+1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                    x=x_Cut #Cut point on x-axis, vertical wall
                    y=y_Cut #Cut point on y-axis, horizontal wall
                    Punched = False
                    while not(Punched):
                        y=random.randint(y_Cut,y_TL) #Randomlize the hole point, even number is wall, odd number is path
                        if y%2 == 0 : #Check is the hole point is wall
                            if y == y_Cut:
                                y=y+1 #Making sure the hole point is path and within the chunk
                            else:
                                y=y-1 #Making sure the hole point is path
                        if Board[x][y] != " ":
                            Punched = True #Making sure the hole is not at the same position as previous hole
                            Board[x][y]=" " #Making the hole in the wall
                Chunk_TL_N=Chunk_TL #Update the top left corner of the chunk
                x_TR=x_Cut-1 #Update the top right corner of the chunk
                Chunk_TR_N=grid(x_TR,y_TR)
                y_BL=y_Cut+1 #Update the bottom left corner of the chunk
                Chunk_BL_N=grid(x_BL,y_BL)
                x_BR=x_Cut-1 #Update the bottom right corner of the chunk
                y_BR=y_Cut+1
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk[0]=Chunk_TL_N #Store the updated chunk
                Chunk[1]=Chunk_TR_N
                Chunk[2]=Chunk_BL_N
                Chunk[3]=Chunk_BR_N
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                Chunk_TL_N=grid(x_TL,y_TL)
                Chunk_TR_N=Chunk_TR #Store the top right corner of the new chunk
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                y_BL=y_Cut+1
                Chunk_BL_N=grid(x_BL,y_BL)
                y_BR=y_Cut+1 #Store the bottom right corner of the new chunk
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                y_TL=y_Cut-1 #Store the top left corner of the new chunk
                Chunk_TL_N=grid(x_TL,y_TL)
                x_TR=x_Cut-1 #Store the top right corner of the new chunk
                y_TR=y_Cut-1
                Chunk_TR_N=grid(x_TR,y_TR)
                Chunk_BL_N=Chunk_BL #Store the bottom left corner of the new chunk
                x_BR=x_Cut-1 #Store the bottom right corner of the new chunk
                Chunk_BR_N=grid(x_BR,y_BR)
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
                x_TL=int(Chunk_TL[0:2]) #Restore the chunk location vector from Grid format
                y_TL=int(Chunk_TL[2:4])
                x_TR=int(Chunk_TR[0:2])
                y_TR=int(Chunk_TR[2:4])
                x_BL=int(Chunk_BL[0:2])
                y_BL=int(Chunk_BL[2:4])
                x_BR=int(Chunk_BR[0:2])
                y_BR=int(Chunk_BR[2:4])
                x_TL=x_Cut+1 #Store the top left corner of the new chunk
                y_TL=y_Cut-1
                Chunk_TL_N=grid(x_TL,y_TL)
                y_TR=y_Cut-1 #Store the top right corner of the new chunk
                Chunk_TR_N=grid(x_TR,y_TR)
                x_BL=x_Cut+1 #Store the bottom left corner of the new chunk
                Chunk_BL_N=grid(x_BL,y_BL)
                Chunk_BR_N=Chunk_BR #Store the bottom right corner of the new chunk
                Chunk.append(Chunk_TL_N) #Store the new chunk
                Chunk.append(Chunk_TR_N)
                Chunk.append(Chunk_BL_N)
                Chunk.append(Chunk_BR_N)
                Chunk_num=Chunk_num+1 #Update the number of chunks
            if Chunk_num_F == Chunk_num: #Check is all chunk is finished
                Done=True
    y=Size-1
    Plot=False
    while not(Plot): #Randomize the player position
        x=random.randint(1,(Size-1))
        if x%2 == 0 :
            x=(x%2)+(x//2)+1
            x=x*random.randint(1,2)
            if x%2 == 0 :
                x=x+1
        if not(x >= Size):
            if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the player is start at the end of the path
                Plot=True
    Board[x][y]="P" #Player starting point
    y=0
    Plot=False
    while not(Plot): #Randomize the exit position
        x=random.randint(1,(Size-1))
        if x%2 == 0 :
            x=(x%2)+(x//2)+1
            x=x*random.randint(1,2)
            if x%2 == 0 :
                x=x+1
        if not(x >= Size):
            if Board[x-1][y+1] == "X" or Board[x+1][y+1] == "X": #Making sure the exit is at the end of the path
                Plot=True
    Board[x][y]="E" #Exit point
    if mode == 1:
        print("System: Maze 0"+mn+" loaded successfully")
        time.sleep(0.1)
    maze_solve()

def check_state(Maze,Not_Maze,Done): #Loop-erased random walk method debug function
    global temp_Maze
    global temp_Not_Maze
    global temp_Done
    temp_Maze=Maze
    temp_Not_Maze=Not_Maze
    temp_Done=Done
    
def print_state(): #Loop-erased random walk method debug function
    print("")
    print_board()
    print("")
    print("System: Printing maze state...")
    print("Maze:")
    for y in range(int((Size-1)/2)):
        print(*[temp_Maze[x][int((Size-1)/2)-y-1] for x in range(int((Size-1)/2))])
    print("Not Maze:"+ str(temp_Not_Maze))
    print("Done:", temp_Done)

def grid(x,y): #Convert Location vector to Grid format
    #Grid format: Location vector in "0519" form, x=5 y=19
    if x<10:
        temp="0"+str(x)
    else:
        temp=str(x)
    if y<10:
        temp=temp+"0"+str(y)
    else:
        temp=temp+str(y)
    return temp

def maze_solve():
    global Board
    global Size
    global Difficulty
    global rec_step
    retry_cycle=0
    passed = False
    if mode == 1:
        print("System: Calculating recommended steps...")
    while not (passed):
        rec_step=0
        i=1
        if i == 1: #Depth-First Search(DFS)
            Path=[] #Store the walked path in grid format
            Junctions=[] #Store the junctions in grid format
            Junction3=[] #Store the junctions that got 3 exit in grid format
            reach=False #Register is the exit reached
            found=False #Register is the player position found
            x=1
            y=Size-1
            while found != True: #Automated relocate player position
                if Board[x][y] == "P":
                    found=True
                else:
                    x=x+1
                    if x > (Size-1):
                        print("System: ERROR")
                        print("System: Player position not found, please restart the game")
                        input("System: Press Enter to exit the game ")
                        sys.exit()
            y=y-1
            rec_step=rec_step+1
            Board[x][y]="0"
            Path.append(grid(x,y))
            while not(reach): #Check is the exit reached
                exit_way=[] #Direction of walkable path
                exit_num=0 #Number of walkable path
                direction=None #Direction of walk
                if Board[x][y-1] == "E": #Check is the bottom box the exit
                    rec_step=rec_step+1
                    reach=True
                elif Board[x][y-1] == " ": #Check is the bottom box the path
                    exit_num=exit_num+1
                    exit_way.append("down")
                if Board[x-1][y] == " ": #Check is the left box the path
                    exit_num=exit_num+1
                    exit_way.append("left")
                if Board[x][y+1] == " ": #Check is the top box the path
                    exit_num=exit_num+1
                    exit_way.append("up")
                if Board[x+1][y] == " ": #Check is the right box the path
                    exit_num=exit_num+1
                    exit_way.append("right")
                if exit_num == 1: #One-way path
                    direction=0
                elif exit_num == 2: #2-way junction
                    Junctions.append(grid(x,y))
                    direction=random.randint(0,1) #Random choose a way to walk
                elif exit_num == 3: #3-way junction
                    Junctions.append(grid(x,y))
                    Junction3.append(grid(x,y))
                    direction=random.randint(0,2) #Random choose a way to walk
                if reach != True:
                    if direction != None:
                        if exit_way[direction] == "up": #Walk up
                            y=y+1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "down": #Walk down
                            y=y-1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "left": #Walk left
                            x=x-1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                        elif exit_way[direction] == "right": #Walk right
                            x=x+1
                            rec_step=rec_step+1
                            Board[x][y]="0"
                            Path.append(grid(x,y))
                    elif (direction == None) and (exit_num == 0): #Dead end
                        back=False
                        while not(back): #Check did it arrive the previous junction
                            Board[x][y]="/"
                            Path.pop()
                            rec_step=rec_step-1
                            temp=Path[len(Path)-1] #Move back
                            x=int(temp[0:2])
                            y=int(temp[2:4])
                            if len(Junction3) != 0: #Check is there any 3-way junction
                                if temp == Junction3[len(Junction3)-1]: #Check is it at the 3-way junction
                                    Junction3.pop()
                                    back=True
                            if back != True:
                                if temp == Junctions[len(Junctions)-1]: #Check is it at the junction
                                    Junctions.pop()
                                    back=True
            x=1
            y=0
            while (x != Size-2) or (y != Size-2): #Cleaning up the board
                if y+1 == Size-1: #Check did it reach the top
                    y=1
                    x=x+1
                else:
                    y=y+1
                if Board[x][y] != "X": #Replace the path
                    Board[x][y]=" "
        elif i == 2: #Breadth-First Search(BFS)
            None
        elif i == 3: #A* Search
            None
        min_step=Size*Size*0.1 #Minimum steps for the maze
        if rec_step <= min_step: #Make sure the recommended steps is not too low
            for k in range(Size): #Redraw the top and bottom edge
                Board[k][0] = "X"
                Board[k][Size-1] = "X"
            y=Size-1
            Plot=False
            while not(Plot): #Randomize the player position
                x=random.randint(1,(Size-1))
                if x%2 == 0 :
                    x=(x%2)+(x//2)+1
                    x=x*random.randint(1,2)
                    if x%2 == 0 :
                        x=x+1
                if not(x >= Size):
                    if Board[x-1][y-1] == "X" or Board[x+1][y-1] == "X": #Making sure the player is start at the end of the path
                        Plot=True
            Board[x][y]="P" #Player starting point
            y=0
            Plot=False
            while not(Plot): #Randomize the exit position
                x=random.randint(1,(Size-1))
                if x%2 == 0 :
                    x=(x%2)+(x//2)+1
                    x=x*random.randint(1,2)
                    if x%2 == 0 :
                        x=x+1
                if not(x >= Size):
                    if Board[x-1][y+1] == "X" or Board[x+1][y+1] == "X": #Making sure the exit is at the end of the path
                        Plot=True
            Board[x][y]="E" #Exit point
            retry_cycle=retry_cycle+1
            if retry_cycle == 3: #Maximum number of retry
                build_maze() #Restart the maze generation if it exceed the maximum number of retry
        else:
            passed=True
    rec_step=rec_step+10 #Add some buffer to the recommended steps
    if mode == 1:
        print("System: Recommend steps for this maze:", rec_step)
        time.sleep(0.1)
        game()
    elif mode == 2:
        draw_maze()
    else:
        print("System: ERROR")
        print("System: User interface not recognised, please restart the game")
        ans=input("System: Press Enter to exit the game ")
        sys.exit()

def Timer(): #10 minutes timer (Sub-thread)
    Time_up=False
    Minutes=10
    Second=60
    while not(Time_up):
        time.sleep(1)
        Second=Second-1
        if Second < 0:
            Minutes=Minutes-1
            Second=60
        if (Minutes == 0) and (Second == 0):
            Time_up=True
    print("Times up")

def main(): #Cmd menu
    global Size
    global Board
    global steps
    global Type_error
    global Difficulty
    global mode
    steps=0
    Type_error=False
    print("System: This game is for single players")
    time.sleep(1)
    print("System: The icon 'X' represent the wall, and icon ' ' represent the path")
    time .sleep(1)
    print("System: Icon 'P' is the player, and icon 'E' is the exit")
    time.sleep(1)
    print("System: You can move in four directions")
    time.sleep(1)
    print("System: Up(W), Down(S), Left(A), Right(D)")
    time.sleep(1)
    print("System: Single character is entered everytime")
    time.sleep(1)
    print("System: Press Enter to execute the action")
    time.sleep(1)
    print("System: Every steps you take will be recorded")
    time.sleep(1)
    print("System: Your goal is to exit the maze with fewest steps")
    time.sleep(1)
    print("System: In Hardcore Mode your steps was limmited, think carefully before moving")
    time.sleep(1)
    print("System: You are not allow to use more steps than the system recommended in Hardcore Mode")
    time.sleep(1)
    ans=input("System: Press Enter to start the game or enter /GUI to swap to GUI manu")
    if ans.lower() == "/gui":
        mode=2
        menu_setup() #Swap to graphical user interface
    else:
        passed=False
        while not passed:
            try:
                ans=int(input("System: Please enter difficulty: 1(21*21 Board), 2(31*31 Board), 3(41*41 Board), 4(51*51 Board), 5(Hardcore Mode) "))
                if ans <=0 or ans > 5:
                    print("System: Out of bounds")
                else:
                    passed=True
                    Difficulty=ans
            except:
                print("System: Formet error")
        if Difficulty == 5:
            ans=4
        Size=(ans+1)*10+1 #Calculate board size
        print("System: Good luck!")
        time.sleep(0.5)
        build_maze()

def menu_setup(): #GUI menu setup
    global t
    global screen
    global pen
    global FPS
    FPS=60
    screen=t.Screen()
    screen.title("Maze Game")
    screen.bgcolor("White")
    screen.setup(width=550, height=650)
    screen.tracer(0)
    refrash()
    pen=t.Turtle()
    pen.hideturtle()
    pen.penup()
    screen.mainloop
    menu()

def menu(): #GUI main menu
    global t
    global screen
    global page
    global pen
    global Instruction_bt
    global Start_bt
    global Setting_bt
    global Exit_bt
    global Cmd_bt
    page=0 #Menu id
    pen.penup()
    pen.clear() #Clear the board
    pen.goto(0,200)
    pen.pendown()
    pen.write("Maze Game", align="center", font=("Arial", 50, "bold")) #Game title
    pen.penup()
    Instruction_bt=Button(-100,125,200,50,"Instruction")
    Instruction_bt.draw() #Draw instruction button
    Start_bt=Button(-100,25,200,50,"Start")
    Start_bt.draw() #Draw start button
    Setting_bt=Button(-100,-75,200,50,"Setting")
    Setting_bt.draw() #Draw setting button
    Exit_bt=Button(-250,-250,100,50,"Exit")
    Exit_bt.draw() #Draw exit button
    Cmd_bt=Button(150,-250,100,50,"Cmd")
    Cmd_bt.draw() #Draw cmd button
    screen.listen()
    screen.onclick(button_click)

def refrash(): #GUI FPS
    global screen
    global FPS
    screen.update()
    screen.ontimer(refrash, 1000//FPS) #FPS control

def button_click(x,y): #Mouse clicked
    global screen
    global page
    global Difficulty
    global mode
    global Size
    global Instruction_bt #Instruction button
    global Start_bt #Start button
    global Setting_bt #Setting button
    global Exit_bt #Exit button
    global Return_bt #Return button
    global Cmd_bt #Cmd button
    global Difficulty_btL #Difficulty left arrow button
    global Difficulty_btR #Difficulty right arrow button
    if page == 0: #From menu
        if Instruction_bt.get_x_min() < x < Instruction_bt.get_x_max() and Instruction_bt.get_y_min() < y < Instruction_bt.get_y_max(): #Instruction button pressed
            instruction()
        elif Start_bt.get_x_min() < x < Start_bt.get_x_max() and Start_bt.get_y_min() < y < Start_bt.get_y_max(): #Start button pressed
            Difficulty=1
            game_setting()
        elif Setting_bt.get_x_min() < x < Setting_bt.get_x_max() and Setting_bt.get_y_min() < y < Setting_bt.get_y_max(): #Setting button pressed
            setting()
        elif Exit_bt.get_x_min() < x < Exit_bt.get_x_max() and Exit_bt.get_y_min() < y < Exit_bt.get_y_max(): #Exit button pressed
            screen.clear()
            sys.exit()
        elif Cmd_bt.get_x_min() < x < Cmd_bt.get_x_max() and Cmd_bt.get_y_min() < y < Cmd_bt.get_y_max(): #Cmd button pressed
            screen.clear()
            mode=1
            main() #Swap to command line interface
    elif page == 1: #From instruction
        if Return_bt.get_x_min() < x < Return_bt.get_x_max() and Return_bt.get_y_min() < y < Return_bt.get_y_max(): #Return button pressed
            menu()
    elif page == 2: #From game_setting
        if Return_bt.get_x_min() < x < Return_bt.get_x_max() and Return_bt.get_y_min() < y < Return_bt.get_y_max(): #Return button pressed
            menu()
        elif Difficulty_btL.get_x_min() < x < Difficulty_btL.get_x_max() and Difficulty_btL.get_y_min() < y < Difficulty_btL.get_y_max(): #Difficulty left arrow button pressed
            if Difficulty > 1: #Decrease difficulty
                Difficulty=Difficulty-1
                game_setting()
        elif Difficulty_btR.get_x_min() < x < Difficulty_btR.get_x_max() and Difficulty_btR.get_y_min() < y < Difficulty_btR.get_y_max(): #Difficulty right arrow button pressed
            if Difficulty < 5: #Increase difficulty
                Difficulty=Difficulty+1
                game_setting()
        elif Start_bt.get_x_min() < x < Start_bt.get_x_max() and Start_bt.get_y_min() < y < Start_bt.get_y_max(): #Start button pressed
            game_setup()
    elif page == 3: #From setting
        if Return_bt.get_x_min() < x < Return_bt.get_x_max() and Return_bt.get_y_min() < y < Return_bt.get_y_max(): #Return button pressed
            menu()

def instruction(): #GUI instruction
    global screen
    global page
    global pen
    global Return_bt
    page=1
    pen.clear() #Reset board
    style="Arial", 15, "bold"
    y=275 #Fist row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- This game is for single players -", align="center", font=(style))
    pen.penup()
    y=y-50 #Second row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- Icon 'P' is the player -", align="center", font=(style))
    pen.penup()
    y=y-50 #Third row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- And icon 'E' is the exit -", align="center", font=(style))
    pen.penup()
    y=y-50 #Fourth row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- You can move in four directions -", align="center", font=(style))
    pen.penup()
    y=y-50 #Fifth row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- Up(W), Down(S), Left(A), Right(D) -", align="center", font=(style))
    pen.penup()
    y=y-50 #Sixth row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- Every steps you take will be recorded -", align="center", font=(style))
    pen.penup()
    y=y-50 #Seventh row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- Your goal is to exit the maze with fewest steps -", align="center", font=(style))
    pen.penup()
    y=y-50 #Eighth row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- In Hardcore Mode your steps was limmited -", align="center", font=(style))
    pen.penup()
    y=y-50 #Nineth row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- Think carefully before moving -", align="center", font=(style))
    pen.penup()
    y=y-50 #Tenth row
    pen.goto(0,y)
    pen.pendown()
    pen.write("- You are not allow to use more steps than", align="center", font=(style))
    pen.penup()
    y=y-50 #Eleventh row
    pen.goto(0,y)
    pen.pendown()
    pen.write("the system recommended in Hardcore Mode -", align="center", font=(style))
    pen.penup()
    Return_bt=Button(-250,-250,125,50,"Return")
    Return_bt.draw() #Draw return button
    screen.listen()
    screen.onclick(button_click)

def game_setting(): #GUI game setting
    global screen
    global page
    global pen
    global Difficulty
    global Difficulty_btL
    global Difficulty_btR
    global Start_bt
    global Return_bt
    page=2
    pen.clear() #Reset board
    x=-170 #Difficulty text position
    y=25
    pen.goto(x,y-42.5)
    pen.pendown()
    pen.write("Difficulty:", align="center", font=("Arial", 25, "bold"))
    pen.penup()
    x=x+85 #Difficulty text to difficulty left arrow button TL position
    Difficulty_btL=Button_L(x,y,25,50)
    Difficulty_btL.draw()
    x=x+30 #Difficulty left arrow button TL to difficulty display TL position
    pen.penup() #Finish drawing left arrow button
    if Difficulty == 1: #Set difficulty
        text="1(21*21 Board)"
    elif Difficulty == 2:
        text="2(31*31 Board)"
    elif Difficulty == 3:
        text="3(41*41 Board)"
    elif Difficulty == 4:
        text="4(51*51 Board)"
    elif Difficulty == 5:
        text="5(Hardcore Mode)"
    Difficulty_dp=Button(x,y,285,50,text)
    Difficulty_dp.draw() #Draw current difficulty display
    pen.penup() #Finish drawing current difficulty display
    x=x+290 #Difficulty display to difficulty right arrow button TL position
    Difficulty_btR=Button_R(x,y,25,50)
    Difficulty_btR.draw()
    Start_bt=Button(-50,-100,100,50,"Start")
    Start_bt.draw() #Draw start button
    Return_bt=Button(-250,-250,125,50,"Return")
    Return_bt.draw() #Draw return button
    screen.listen()
    screen.onclick(button_click)

def setting(): #GUI setting
    global screen
    global page
    global pen
    global Return_bt
    page=3
    pen.clear() #Reset board
    pen.goto(0,0)
    Return_bt=Button(-250,-250,125,50,"Return")
    Return_bt.draw() #Draw return button
    screen.listen()
    screen.onclick(button_click)

def game_setup(): #Game GUI setup
    global t
    global screen
    global Size
    global Ratio
    global FPS
    screen.clear()
    screen=t.Screen()
    screen.title("Maze Game")
    screen.bgcolor("White")
    temp=Difficulty
    if Difficulty == 5:
        temp=4
    Size=(temp+1)*10+1 #Calculate board size
    if Size == 21 :
        Ratio=30
    elif Size == 31:
        Ratio=20
    elif Size == 41:
        Ratio=15
    elif Size == 51:
        Ratio=12.5
    screen.setup(width=Size*Ratio, height=Size*Ratio)
    screen.tracer(0)
    refrash()
    pen=t.Turtle() #Use to draw maze
    pen.shapesize((Ratio/20), (Ratio/20))
    pen.penup()
    pen.color("black")
    pen.showturtle()
    pen.goto((Ratio/4),0) #Center
    player=t.Turtle() #Player control character and text display when drawing maze
    player.shapesize((Ratio/20), (Ratio/20))
    player.penup()
    player.color("Green")
    player.showturtle()
    player.goto(-(Ratio/8),-(Ratio/4)) #Center
    player.setheading(270)
    wall_block(100,100)

def draw_maze():
    global Board
    global pen
    global screen
    global Size
    global Ratio

def wall_block(x,y):
    global pen
    global Ratio
    pen.goto(x,y) #Top left
    pen.pendown()
    pen.begin_fill()
    pen.goto(x+Ratio,y) #Top right
    pen.goto(x+Ratio,y-Ratio)#Bottom right
    pen.goto(x,y-Ratio)#Bottom left
    pen.goto(x,y) #Top left
    pen.end_fill()
    pen.penup()

class Button:
    def __init__(self, x, y, width, height, text):
        self.x=x #Top left x coordinate
        self.y=y #Top left y coordinate
        self.width=width
        self.height=height
        self.text=text
    
    def get_x_min(self): #Return the x value bottom bound
        return self.x
    
    def get_x_max(self): #Return the x value upper bound
        return self.x+self.width
    
    def get_y_min(self): #Return the y value bottom bound
        return self.y-self.height
    
    def get_y_max(self): #Return the y value upper bound
        return self.y

    def draw(self): #Draw button
        global screen
        global pen
        pen.goto(self.x,self.y) #TL of the button
        pen.pendown() #Start drawing the button
        pen.goto(self.x+self.width,self.y) #TR of the button
        pen.goto(self.x+self.width,self.y-self.height) #BR of the button
        pen.goto(self.x,self.y-self.height) #BL of the button
        pen.goto(self.x,self.y) #TL of the button
        pen.penup()
        pen.goto(self.x+(self.width/2),self.y-self.height+5)
        pen.pendown() #Write text
        pen.write(self.text, align="center", font=("Arial", 25, "bold"))
        pen.penup() #Finish drawing the button

class Button_L: #Left arrow button
    def __init__(self, x, y, width, height):
        self.x=x #Top left x coordinate
        self.y=y #Top left y coordinate
        self.width=width
        self.height=height

    def get_x_min(self): #Return the x value bottom bound
        return self.x
    
    def get_x_max(self): #Return the x value upper bound
        return self.x+self.width
    
    def get_y_min(self): #Return the y value bottom bound
        return self.y-self.height
    
    def get_y_max(self): #Return the y value upper bound
        return self.y

    def draw(self): #Draw button
        global pen
        pen.goto(self.x,self.y) #TL of the button
        pen.pendown() #Start drawing the button
        pen.goto(self.x+self.width,self.y) #TR of the button
        pen.goto(self.x+self.width,self.y-self.height) #BR of the button
        pen.goto(self.x,self.y-self.height) #BL of the button
        pen.goto(self.x,self.y) #TL of the button
        pen.penup()
        pen.goto(self.x+5,self.y-self.height/2) #Arrow left point
        pen.pendown() #Start drawing arrow
        pen.begin_fill()
        pen.fillcolor("black")
        pen.goto(self.x+self.width-5,self.y-5) #Arrow top right point
        pen.goto(self.x+self.width-5,self.y-self.height+5) #Arrow bottom right point
        pen.goto(self.x+5,self.y-self.height/2) #Arrow left point
        pen.end_fill()
        pen.penup() #Finish drawing the button

class Button_R: #Right arrow button
    def __init__(self, x, y, width, height):
        self.x=x #Top left x coordinate
        self.y=y #Top left y coordinate
        self.width=width
        self.height=height

    def get_x_min(self): #Return the x value bottom bound
        return self.x
    
    def get_x_max(self): #Return the x value upper bound
        return self.x+self.width
    
    def get_y_min(self): #Return the y value bottom bound
        return self.y-self.height
    
    def get_y_max(self): #Return the y value upper bound
        return self.y

    def draw(self): #Draw button
        global pen
        pen.goto(self.x,self.y) #TL of the button
        pen.pendown() #Start drawing the button
        pen.goto(self.x+self.width,self.y) #TR of the button
        pen.goto(self.x+self.width,self.y-self.height) #BR of the button
        pen.goto(self.x,self.y-self.height) #BL of the button
        pen.goto(self.x,self.y) #TL of the button
        pen.penup()
        pen.goto(self.x+5,self.y-5) #Arrow top left point
        pen.pendown() #Start drawing arrow
        pen.begin_fill()
        pen.fillcolor("black")
        pen.goto(self.x+self.width-5,self.y-self.height/2) #Arrow right point
        pen.goto(self.x+5,self.y-self.height+5) #Arrow bottom leftight point
        pen.goto(self.x+5,self.y-5) #Arrow top left point
        pen.end_fill()
        pen.penup() #Finish drawing the button

import time
import random
import sys
import threading
import turtle as t
menu_setup()
